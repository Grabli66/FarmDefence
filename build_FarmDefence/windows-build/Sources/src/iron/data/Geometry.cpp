// Generated by Haxe 4.0.0-preview.4+6e012c1
#include <hxcpp.h>

#ifndef INCLUDED_c5728fd05c542abe
#define INCLUDED_c5728fd05c542abe
#include "cpp_float32array.h"
#endif
#ifndef INCLUDED_7d028c26efabce49
#define INCLUDED_7d028c26efabce49
#include "cpp_uint32array.h"
#endif
#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Std
#include <hxinc/Std.h>
#endif
#ifndef INCLUDED_haxe_IMap
#include <hxinc/haxe/IMap.h>
#endif
#ifndef INCLUDED_haxe_Log
#include <hxinc/haxe/Log.h>
#endif
#ifndef INCLUDED_haxe_ds_StringMap
#include <hxinc/haxe/ds/StringMap.h>
#endif
#ifndef INCLUDED_iron_data_Armature
#include <hxinc/iron/data/Armature.h>
#endif
#ifndef INCLUDED_iron_data_Geometry
#include <hxinc/iron/data/Geometry.h>
#endif
#ifndef INCLUDED_iron_data_TObj
#include <hxinc/iron/data/TObj.h>
#endif
#ifndef INCLUDED_iron_data_TTransform
#include <hxinc/iron/data/TTransform.h>
#endif
#ifndef INCLUDED_iron_data_TVertexData
#include <hxinc/iron/data/TVertexData.h>
#endif
#ifndef INCLUDED_iron_math_Mat4
#include <hxinc/iron/math/Mat4.h>
#endif
#ifndef INCLUDED_iron_math_Vec4
#include <hxinc/iron/math/Vec4.h>
#endif
#ifndef INCLUDED_kha_arrays_Float32ArrayPrivate
#include <hxinc/kha/arrays/Float32ArrayPrivate.h>
#endif
#ifndef INCLUDED_kha_arrays_Uint32ArrayPrivate
#include <hxinc/kha/arrays/Uint32ArrayPrivate.h>
#endif
#ifndef INCLUDED_kha_graphics4_IndexBuffer
#include <hxinc/kha/graphics4/IndexBuffer.h>
#endif
#ifndef INCLUDED_kha_graphics4_Usage
#include <hxinc/kha/graphics4/Usage.h>
#endif
#ifndef INCLUDED_kha_graphics4_VertexBuffer
#include <hxinc/kha/graphics4/VertexBuffer.h>
#endif
#ifndef INCLUDED_kha_graphics4_VertexElement
#include <hxinc/kha/graphics4/VertexElement.h>
#endif
#ifndef INCLUDED_kha_graphics4_VertexStructure
#include <hxinc/kha/graphics4/VertexStructure.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_0883a6c134c4202b_14_new,"iron.data.Geometry","new",0x7cdf7ce2,"iron.data.Geometry.new","iron/data/Geometry.hx",14,0x3ca6746e)
HX_LOCAL_STACK_FRAME(_hx_pos_0883a6c134c4202b_109_delete,"iron.data.Geometry","delete",0x1dce50e9,"iron.data.Geometry.delete","iron/data/Geometry.hx",109,0x3ca6746e)
HX_LOCAL_STACK_FRAME(_hx_pos_0883a6c134c4202b_131_applyScale,"iron.data.Geometry","applyScale",0x0f4011fa,"iron.data.Geometry.applyScale","iron/data/Geometry.hx",131,0x3ca6746e)
HX_LOCAL_STACK_FRAME(_hx_pos_0883a6c134c4202b_151_setupInstanced,"iron.data.Geometry","setupInstanced",0x40e5fbb0,"iron.data.Geometry.setupInstanced","iron/data/Geometry.hx",151,0x3ca6746e)
HX_LOCAL_STACK_FRAME(_hx_pos_0883a6c134c4202b_200_copyVertices,"iron.data.Geometry","copyVertices",0x2e5e280c,"iron.data.Geometry.copyVertices","iron/data/Geometry.hx",200,0x3ca6746e)
HX_LOCAL_STACK_FRAME(_hx_pos_0883a6c134c4202b_266_getVerticesLength,"iron.data.Geometry","getVerticesLength",0xd4c704f7,"iron.data.Geometry.getVerticesLength","iron/data/Geometry.hx",266,0x3ca6746e)
HX_LOCAL_STACK_FRAME(_hx_pos_0883a6c134c4202b_295_hasAttrib,"iron.data.Geometry","hasAttrib",0xa1809446,"iron.data.Geometry.hasAttrib","iron/data/Geometry.hx",295,0x3ca6746e)
HX_LOCAL_STACK_FRAME(_hx_pos_0883a6c134c4202b_300_get,"iron.data.Geometry","get",0x7cda2d18,"iron.data.Geometry.get","iron/data/Geometry.hx",300,0x3ca6746e)
HX_LOCAL_STACK_FRAME(_hx_pos_0883a6c134c4202b_327_build,"iron.data.Geometry","build",0x331c2c30,"iron.data.Geometry.build","iron/data/Geometry.hx",327,0x3ca6746e)
HX_LOCAL_STACK_FRAME(_hx_pos_0883a6c134c4202b_394_getVerticesCount,"iron.data.Geometry","getVerticesCount",0x82e141de,"iron.data.Geometry.getVerticesCount","iron/data/Geometry.hx",394,0x3ca6746e)
HX_LOCAL_STACK_FRAME(_hx_pos_0883a6c134c4202b_399_addArmature,"iron.data.Geometry","addArmature",0xee81da3c,"iron.data.Geometry.addArmature","iron/data/Geometry.hx",399,0x3ca6746e)
HX_LOCAL_STACK_FRAME(_hx_pos_0883a6c134c4202b_404_addAction,"iron.data.Geometry","addAction",0x4ee56ab9,"iron.data.Geometry.addAction","iron/data/Geometry.hx",404,0x3ca6746e)
HX_LOCAL_STACK_FRAME(_hx_pos_0883a6c134c4202b_430_initSkeletonTransforms,"iron.data.Geometry","initSkeletonTransforms",0xa88c79a2,"iron.data.Geometry.initSkeletonTransforms","iron/data/Geometry.hx",430,0x3ca6746e)
HX_LOCAL_STACK_FRAME(_hx_pos_0883a6c134c4202b_457_calculateAABB,"iron.data.Geometry","calculateAABB",0x362dce08,"iron.data.Geometry.calculateAABB","iron/data/Geometry.hx",457,0x3ca6746e)
HX_LOCAL_STACK_FRAME(_hx_pos_0883a6c134c4202b_118_getVertexStructure,"iron.data.Geometry","getVertexStructure",0xc54e21f7,"iron.data.Geometry.getVertexStructure","iron/data/Geometry.hx",118,0x3ca6746e)
HX_LOCAL_STACK_FRAME(_hx_pos_0883a6c134c4202b_213_buildVertices,"iron.data.Geometry","buildVertices",0xfe335849,"iron.data.Geometry.buildVertices","iron/data/Geometry.hx",213,0x3ca6746e)
namespace iron{
namespace data{

void Geometry_obj::__construct(::Array< ::Dynamic> indices,::Array< int > materialIndices, ::kha::arrays::Float32ArrayPrivate positions, ::kha::arrays::Float32ArrayPrivate normals, ::kha::arrays::Float32ArrayPrivate uvs, ::kha::arrays::Float32ArrayPrivate uvs1, ::kha::arrays::Float32ArrayPrivate cols, ::kha::arrays::Float32ArrayPrivate tangents, ::kha::arrays::Float32ArrayPrivate bones, ::kha::arrays::Float32ArrayPrivate weights, ::kha::graphics4::Usage usage, ::kha::arrays::Float32ArrayPrivate instancedData, ::Dynamic instancedType){
            	HX_GC_STACKFRAME(&_hx_pos_0883a6c134c4202b_14_new)
HXLINE(  69)		this->mats = null();
HXLINE(  68)		this->actions = null();
HXLINE(  66)		this->skeletonBoneLens = null();
HXLINE(  65)		this->skeletonBoneRefs = null();
HXLINE(  64)		this->skeletonTransformsI = null();
HXLINE(  62)		this->skinBoneWeights = null();
HXLINE(  61)		this->skinBoneIndices = null();
HXLINE(  60)		this->skinBoneCounts = null();
HXLINE(  52)		this->aabb = null();
HXLINE(  38)		this->instanceCount = 0;
HXLINE(  37)		this->instanced = false;
HXLINE(  36)		this->instancedVB = null();
HXLINE(  29)		this->numTris = 0;
HXLINE(  26)		this->ready = false;
HXLINE(  24)		this->name = HX_("",00,00,00,00);
HXLINE(  23)		this->count = -1;
HXLINE(  22)		this->start = 0;
HXLINE(  19)		this->vertexBufferMap =  ::haxe::ds::StringMap_obj::__alloc( HX_CTX );
HXLINE(  85)		if (hx::IsNull( usage )) {
HXLINE(  85)			usage = ::kha::graphics4::Usage_obj::StaticUsage_dyn();
            		}
HXLINE(  87)		this->indices = indices;
HXLINE(  88)		this->materialIndices = materialIndices;
HXLINE(  89)		this->usage = usage;
HXLINE(  91)		this->positions = positions;
HXLINE(  92)		this->normals = normals;
HXLINE(  93)		this->uvs = uvs;
HXLINE(  94)		this->uvs1 = uvs1;
HXLINE(  95)		this->cols = cols;
HXLINE(  96)		this->tangents = tangents;
HXLINE(  97)		this->bones = bones;
HXLINE(  98)		this->weights = weights;
HXLINE(  99)		this->instancedData = instancedData;
HXLINE( 100)		this->instancedType = instancedType;
HXLINE( 103)		this->_hx_struct = ::iron::data::Geometry_obj::getVertexStructure(hx::IsNotNull( positions ),hx::IsNotNull( normals ),hx::IsNotNull( uvs ),hx::IsNotNull( uvs1 ),hx::IsNotNull( cols ),hx::IsNotNull( tangents ),hx::IsNotNull( bones ),hx::IsNotNull( weights ));
HXLINE( 104)		this->structLength = ::Std_obj::_hx_int((( (Float)(this->_hx_struct->byteSize()) ) / ( (Float)(4) )));
HXLINE( 105)		this->structStr = HX_("",00,00,00,00);
HXLINE( 106)		{
HXLINE( 106)			int _g = 0;
HXDLIN( 106)			::Array< ::Dynamic> _g1 = this->_hx_struct->elements;
HXDLIN( 106)			while((_g < _g1->length)){
HXLINE( 106)				 ::kha::graphics4::VertexElement e = _g1->__get(_g).StaticCast<  ::kha::graphics4::VertexElement >();
HXDLIN( 106)				_g = (_g + 1);
HXDLIN( 106)				 ::iron::data::Geometry _hx_tmp = hx::ObjectPtr<OBJ_>(this);
HXDLIN( 106)				_hx_tmp->structStr = (_hx_tmp->structStr + e->name);
            			}
            		}
            	}

Dynamic Geometry_obj::__CreateEmpty() { return new Geometry_obj; }

void *Geometry_obj::_hx_vtable = 0;

Dynamic Geometry_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< Geometry_obj > _hx_result = new Geometry_obj();
	_hx_result->__construct(inArgs[0],inArgs[1],inArgs[2],inArgs[3],inArgs[4],inArgs[5],inArgs[6],inArgs[7],inArgs[8],inArgs[9],inArgs[10],inArgs[11],inArgs[12]);
	return _hx_result;
}

bool Geometry_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x7fb2fc44;
}

void Geometry_obj::_hx_delete(){
            	HX_STACKFRAME(&_hx_pos_0883a6c134c4202b_109_delete)
HXLINE( 113)		this->vertexBuffer->_hx_delete();
HXLINE( 115)		{
HXLINE( 115)			int _g = 0;
HXDLIN( 115)			::Array< ::Dynamic> _g1 = this->indexBuffers;
HXDLIN( 115)			while((_g < _g1->length)){
HXLINE( 115)				 ::kha::graphics4::IndexBuffer buf = _g1->__get(_g).StaticCast<  ::kha::graphics4::IndexBuffer >();
HXDLIN( 115)				_g = (_g + 1);
HXDLIN( 115)				buf->_hx_delete();
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(Geometry_obj,_hx_delete,(void))

void Geometry_obj::applyScale(Float sx,Float sy,Float sz){
            	HX_STACKFRAME(&_hx_pos_0883a6c134c4202b_131_applyScale)
HXLINE( 141)		 ::kha::arrays::Float32ArrayPrivate vertices = this->vertexBuffer->lock(null(),null());
HXLINE( 142)		{
HXLINE( 142)			int _g1 = 0;
HXDLIN( 142)			int _g = vertices->self.length();
HXDLIN( 142)			int _g2 = ::Std_obj::_hx_int((( (Float)(_g) ) / ( (Float)(this->structLength) )));
HXDLIN( 142)			while((_g1 < _g2)){
HXLINE( 142)				_g1 = (_g1 + 1);
HXDLIN( 142)				int i = (_g1 - 1);
HXLINE( 143)				{
HXLINE( 143)					int _g21 = (i * this->structLength);
HXDLIN( 143)					 ::kha::arrays::Float32ArrayPrivate _g3 = vertices;
HXDLIN( 143)					{
HXLINE( 143)						float value = ( (float)((_g3->self.get(_g21) * sx)) );
HXDLIN( 143)						_g3->self.set(_g21,value);
            					}
            				}
HXLINE( 144)				{
HXLINE( 144)					int _g22 = ((i * this->structLength) + 1);
HXDLIN( 144)					 ::kha::arrays::Float32ArrayPrivate _g31 = vertices;
HXDLIN( 144)					{
HXLINE( 144)						float value1 = ( (float)((_g31->self.get(_g22) * sy)) );
HXDLIN( 144)						_g31->self.set(_g22,value1);
            					}
            				}
HXLINE( 145)				{
HXLINE( 145)					int _g23 = ((i * this->structLength) + 2);
HXDLIN( 145)					 ::kha::arrays::Float32ArrayPrivate _g32 = vertices;
HXDLIN( 145)					{
HXLINE( 145)						float value2 = ( (float)((_g32->self.get(_g23) * sz)) );
HXDLIN( 145)						_g32->self.set(_g23,value2);
            					}
            				}
            			}
            		}
HXLINE( 147)		this->vertexBuffer->unlock();
            	}


HX_DEFINE_DYNAMIC_FUNC3(Geometry_obj,applyScale,(void))

void Geometry_obj::setupInstanced( ::kha::arrays::Float32ArrayPrivate data,int instancedType, ::kha::graphics4::Usage usage){
            	HX_GC_STACKFRAME(&_hx_pos_0883a6c134c4202b_151_setupInstanced)
HXLINE( 158)		this->instanced = true;
HXLINE( 159)		this->instanceCount = ::Std_obj::_hx_int((( (Float)(data->self.length()) ) / ( (Float)(3) )));
HXLINE( 161)		 ::kha::graphics4::VertexStructure structure =  ::kha::graphics4::VertexStructure_obj::__alloc( HX_CTX );
HXLINE( 162)		structure->instanced = true;
HXLINE( 164)		structure->add(HX_("ipos",cb,c4,bc,45),2);
HXLINE( 165)		bool _hx_tmp;
HXDLIN( 165)		if ((instancedType != 2)) {
HXLINE( 165)			_hx_tmp = (instancedType == 4);
            		}
            		else {
HXLINE( 165)			_hx_tmp = true;
            		}
HXDLIN( 165)		if (_hx_tmp) {
HXLINE( 166)			structure->add(HX_("irot",4e,49,be,45),2);
            		}
HXLINE( 168)		bool _hx_tmp1;
HXDLIN( 168)		if ((instancedType != 3)) {
HXLINE( 168)			_hx_tmp1 = (instancedType == 4);
            		}
            		else {
HXLINE( 168)			_hx_tmp1 = true;
            		}
HXDLIN( 168)		if (_hx_tmp1) {
HXLINE( 169)			structure->add(HX_("iscl",13,01,bf,45),2);
            		}
HXLINE( 172)		this->instancedVB =  ::kha::graphics4::VertexBuffer_obj::__alloc( HX_CTX ,this->instanceCount,structure,usage,1,null());
HXLINE( 173)		 ::kha::arrays::Float32ArrayPrivate vertices = this->instancedVB->lock(null(),null());
HXLINE( 174)		{
HXLINE( 174)			int _g1 = 0;
HXDLIN( 174)			int _g = vertices->self.length();
HXDLIN( 174)			while((_g1 < _g)){
HXLINE( 174)				_g1 = (_g1 + 1);
HXDLIN( 174)				int i = (_g1 - 1);
HXDLIN( 174)				{
HXLINE( 174)					float value = data->self.get(i);
HXDLIN( 174)					vertices->self.set(i,value);
            				}
            			}
            		}
HXLINE( 175)		this->instancedVB->unlock();
            	}


HX_DEFINE_DYNAMIC_FUNC3(Geometry_obj,setupInstanced,(void))

void Geometry_obj::copyVertices( ::kha::arrays::Float32ArrayPrivate vertices,hx::Null< int >  __o_offset,hx::Null< bool >  __o_fakeUVs){
int offset = __o_offset.Default(0);
bool fakeUVs = __o_fakeUVs.Default(false);
            	HX_STACKFRAME(&_hx_pos_0883a6c134c4202b_200_copyVertices)
HXDLIN( 200)		::iron::data::Geometry_obj::buildVertices(vertices,this->positions,this->normals,this->uvs,this->uvs1,this->cols,this->tangents,this->bones,this->weights,offset,fakeUVs);
            	}


HX_DEFINE_DYNAMIC_FUNC3(Geometry_obj,copyVertices,(void))

int Geometry_obj::getVerticesLength(){
            	HX_STACKFRAME(&_hx_pos_0883a6c134c4202b_266_getVerticesLength)
HXLINE( 267)		int res = this->positions->self.length();
HXLINE( 268)		if (hx::IsNotNull( this->normals )) {
HXLINE( 268)			res = (res + this->normals->self.length());
            		}
HXLINE( 269)		if (hx::IsNotNull( this->uvs )) {
HXLINE( 269)			res = (res + this->uvs->self.length());
            		}
HXLINE( 270)		if (hx::IsNotNull( this->uvs1 )) {
HXLINE( 270)			res = (res + this->uvs1->self.length());
            		}
HXLINE( 271)		if (hx::IsNotNull( this->cols )) {
HXLINE( 271)			res = (res + this->cols->self.length());
            		}
HXLINE( 272)		if (hx::IsNotNull( this->tangents )) {
HXLINE( 272)			res = (res + this->tangents->self.length());
            		}
HXLINE( 273)		if (hx::IsNotNull( this->bones )) {
HXLINE( 273)			res = (res + this->bones->self.length());
            		}
HXLINE( 274)		if (hx::IsNotNull( this->weights )) {
HXLINE( 274)			res = (res + this->weights->self.length());
            		}
HXLINE( 275)		return res;
            	}


HX_DEFINE_DYNAMIC_FUNC0(Geometry_obj,getVerticesLength,return )

bool Geometry_obj::hasAttrib(::String s,::Array< ::Dynamic> vs){
            	HX_STACKFRAME(&_hx_pos_0883a6c134c4202b_295_hasAttrib)
HXLINE( 296)		{
HXLINE( 296)			int _g = 0;
HXDLIN( 296)			while((_g < vs->length)){
HXLINE( 296)				 ::iron::data::TVertexData e = vs->__get(_g).StaticCast<  ::iron::data::TVertexData >();
HXDLIN( 296)				_g = (_g + 1);
HXDLIN( 296)				if ((e->name == s)) {
HXLINE( 296)					return true;
            				}
            			}
            		}
HXLINE( 297)		return false;
            	}


HX_DEFINE_DYNAMIC_FUNC2(Geometry_obj,hasAttrib,return )

 ::kha::graphics4::VertexBuffer Geometry_obj::get(::Array< ::Dynamic> vs){
            	HX_GC_STACKFRAME(&_hx_pos_0883a6c134c4202b_300_get)
HXLINE( 301)		::String s = HX_("",00,00,00,00);
HXLINE( 302)		{
HXLINE( 302)			int _g = 0;
HXDLIN( 302)			while((_g < vs->length)){
HXLINE( 302)				 ::iron::data::TVertexData e = vs->__get(_g).StaticCast<  ::iron::data::TVertexData >();
HXDLIN( 302)				_g = (_g + 1);
HXDLIN( 302)				s = (s + e->name);
            			}
            		}
HXLINE( 303)		 ::kha::graphics4::VertexBuffer vb = ( ( ::kha::graphics4::VertexBuffer)(this->vertexBufferMap->get(s)) );
HXLINE( 304)		if (hx::IsNull( vb )) {
HXLINE( 306)			bool apos = this->hasAttrib(HX_("pos",94,5d,55,00),vs);
HXLINE( 307)			bool anor = this->hasAttrib(HX_("nor",11,d9,53,00),vs);
HXLINE( 308)			bool atex = this->hasAttrib(HX_("tex",e7,5d,58,00),vs);
HXLINE( 309)			bool atex1 = this->hasAttrib(HX_("tex1",6a,cc,f9,4c),vs);
HXLINE( 310)			bool acol = this->hasAttrib(HX_("col",40,80,4b,00),vs);
HXLINE( 311)			bool atang = this->hasAttrib(HX_("tang",e6,ba,f6,4c),vs);
HXLINE( 312)			bool abone = this->hasAttrib(HX_("bone",44,83,1b,41),vs);
HXLINE( 313)			bool aweight = this->hasAttrib(HX_("weight",78,71,a6,01),vs);
HXLINE( 314)			 ::kha::graphics4::VertexStructure _hx_struct = ::iron::data::Geometry_obj::getVertexStructure(apos,anor,atex,atex1,acol,atang,abone,aweight);
HXLINE( 315)			int vb1 = ::Std_obj::_hx_int((( (Float)(this->positions->self.length()) ) / ( (Float)(3) )));
HXDLIN( 315)			vb =  ::kha::graphics4::VertexBuffer_obj::__alloc( HX_CTX ,vb1,_hx_struct,this->usage,null(),null());
HXLINE( 316)			this->vertices = vb->lock(null(),null());
HXLINE( 317)			 ::kha::arrays::Float32ArrayPrivate _hx_tmp;
HXDLIN( 317)			if (apos) {
HXLINE( 317)				_hx_tmp = this->positions;
            			}
            			else {
HXLINE( 317)				_hx_tmp = null();
            			}
HXDLIN( 317)			 ::kha::arrays::Float32ArrayPrivate _hx_tmp1;
HXDLIN( 317)			if (anor) {
HXLINE( 317)				_hx_tmp1 = this->normals;
            			}
            			else {
HXLINE( 317)				_hx_tmp1 = null();
            			}
HXDLIN( 317)			 ::kha::arrays::Float32ArrayPrivate _hx_tmp2;
HXDLIN( 317)			if (atex) {
HXLINE( 317)				_hx_tmp2 = this->uvs;
            			}
            			else {
HXLINE( 317)				_hx_tmp2 = null();
            			}
HXDLIN( 317)			 ::kha::arrays::Float32ArrayPrivate _hx_tmp3;
HXDLIN( 317)			if (atex1) {
HXLINE( 317)				_hx_tmp3 = this->uvs1;
            			}
            			else {
HXLINE( 317)				_hx_tmp3 = null();
            			}
HXDLIN( 317)			 ::kha::arrays::Float32ArrayPrivate _hx_tmp4;
HXDLIN( 317)			if (acol) {
HXLINE( 317)				_hx_tmp4 = this->cols;
            			}
            			else {
HXLINE( 317)				_hx_tmp4 = null();
            			}
HXDLIN( 317)			 ::kha::arrays::Float32ArrayPrivate _hx_tmp5;
HXDLIN( 317)			if (atang) {
HXLINE( 317)				_hx_tmp5 = this->tangents;
            			}
            			else {
HXLINE( 317)				_hx_tmp5 = null();
            			}
HXDLIN( 317)			 ::kha::arrays::Float32ArrayPrivate _hx_tmp6;
HXDLIN( 317)			if (abone) {
HXLINE( 317)				_hx_tmp6 = this->bones;
            			}
            			else {
HXLINE( 317)				_hx_tmp6 = null();
            			}
HXDLIN( 317)			 ::kha::arrays::Float32ArrayPrivate _hx_tmp7;
HXDLIN( 317)			if (aweight) {
HXLINE( 317)				_hx_tmp7 = this->weights;
            			}
            			else {
HXLINE( 317)				_hx_tmp7 = null();
            			}
HXDLIN( 317)			bool _hx_tmp8;
HXDLIN( 317)			if (atex) {
HXLINE( 317)				_hx_tmp8 = hx::IsNull( this->uvs );
            			}
            			else {
HXLINE( 317)				_hx_tmp8 = false;
            			}
HXDLIN( 317)			::iron::data::Geometry_obj::buildVertices(this->vertices,_hx_tmp,_hx_tmp1,_hx_tmp2,_hx_tmp3,_hx_tmp4,_hx_tmp5,_hx_tmp6,_hx_tmp7,0,_hx_tmp8);
HXLINE( 318)			vb->unlock();
HXLINE( 319)			this->vertexBufferMap->set(s,vb);
HXLINE( 320)			bool _hx_tmp9;
HXDLIN( 320)			if (atex) {
HXLINE( 320)				_hx_tmp9 = hx::IsNull( this->uvs );
            			}
            			else {
HXLINE( 320)				_hx_tmp9 = false;
            			}
HXDLIN( 320)			if (_hx_tmp9) {
HXLINE( 320)				 ::Dynamic _hx_tmp10 = ::haxe::Log_obj::trace;
HXDLIN( 320)				_hx_tmp10(((HX_("Armory Warning: Geometry ",12,f0,86,91) + this->name) + HX_(" is missing UV map",2d,4e,c4,57)),hx::SourceInfo(HX_("Sources/iron/data/Geometry.hx",f7,64,04,7f),320,HX_("iron.data.Geometry",f0,23,2b,36),HX_("get",96,80,4e,00)));
            			}
HXLINE( 321)			bool _hx_tmp11;
HXDLIN( 321)			if (acol) {
HXLINE( 321)				_hx_tmp11 = hx::IsNull( this->cols );
            			}
            			else {
HXLINE( 321)				_hx_tmp11 = false;
            			}
HXDLIN( 321)			if (_hx_tmp11) {
HXLINE( 321)				 ::Dynamic _hx_tmp12 = ::haxe::Log_obj::trace;
HXDLIN( 321)				_hx_tmp12(((HX_("Armory Warning: Geometry ",12,f0,86,91) + this->name) + HX_(" is missing vertex colors",1c,90,3d,c5)),hx::SourceInfo(HX_("Sources/iron/data/Geometry.hx",f7,64,04,7f),321,HX_("iron.data.Geometry",f0,23,2b,36),HX_("get",96,80,4e,00)));
            			}
            		}
HXLINE( 323)		return vb;
            	}


HX_DEFINE_DYNAMIC_FUNC1(Geometry_obj,get,return )

void Geometry_obj::build(){
            	HX_GC_STACKFRAME(&_hx_pos_0883a6c134c4202b_327_build)
HXLINE( 328)		if (this->ready) {
HXLINE( 328)			return;
            		}
HXLINE( 342)		int _hx_tmp = ::Std_obj::_hx_int((( (Float)(this->positions->self.length()) ) / ( (Float)(3) )));
HXDLIN( 342)		this->vertexBuffer =  ::kha::graphics4::VertexBuffer_obj::__alloc( HX_CTX ,_hx_tmp,this->_hx_struct,this->usage,null(),null());
HXLINE( 343)		this->vertices = this->vertexBuffer->lock(null(),null());
HXLINE( 344)		::iron::data::Geometry_obj::buildVertices(this->vertices,this->positions,this->normals,this->uvs,this->uvs1,this->cols,this->tangents,this->bones,this->weights,null(),null());
HXLINE( 345)		this->vertexBuffer->unlock();
HXLINE( 346)		this->vertexBufferMap->set(this->structStr,this->vertexBuffer);
HXLINE( 349)		this->indexBuffers = ::Array_obj< ::Dynamic>::__new(0);
HXLINE( 350)		{
HXLINE( 350)			int _g = 0;
HXDLIN( 350)			::Array< ::Dynamic> _g1 = this->indices;
HXDLIN( 350)			while((_g < _g1->length)){
HXLINE( 350)				 ::kha::arrays::Uint32ArrayPrivate id = _g1->__get(_g).StaticCast<  ::kha::arrays::Uint32ArrayPrivate >();
HXDLIN( 350)				_g = (_g + 1);
HXLINE( 351)				if ((id->self.length() == 0)) {
HXLINE( 351)					continue;
            				}
HXLINE( 352)				int indexBuffer = id->self.length();
HXDLIN( 352)				 ::kha::graphics4::IndexBuffer indexBuffer1 =  ::kha::graphics4::IndexBuffer_obj::__alloc( HX_CTX ,indexBuffer,this->usage,null());
HXLINE( 353)				 ::iron::data::Geometry _hx_tmp1 = hx::ObjectPtr<OBJ_>(this);
HXDLIN( 353)				int _hx_tmp2 = _hx_tmp1->numTris;
HXDLIN( 353)				_hx_tmp1->numTris = (_hx_tmp2 + ::Std_obj::_hx_int((( (Float)(id->self.length()) ) / ( (Float)(3) ))));
HXLINE( 358)				 ::kha::arrays::Uint32ArrayPrivate indicesA = indexBuffer1->lock(null(),null());
HXLINE( 359)				{
HXLINE( 359)					int _g3 = 0;
HXDLIN( 359)					int _g2 = indicesA->self.length();
HXDLIN( 359)					while((_g3 < _g2)){
HXLINE( 359)						_g3 = (_g3 + 1);
HXDLIN( 359)						int i = (_g3 - 1);
HXDLIN( 359)						{
HXLINE( 359)							int value = id->self.get(i);
HXDLIN( 359)							indicesA->self.set(i,value);
            						}
            					}
            				}
HXLINE( 362)				indexBuffer1->unlock();
HXLINE( 363)				this->indexBuffers->push(indexBuffer1);
            			}
            		}
HXLINE( 367)		if (hx::IsNotNull( this->instancedData )) {
HXLINE( 367)			this->setupInstanced(this->instancedData,( (int)(this->instancedType) ),this->usage);
            		}
HXLINE( 369)		this->ready = true;
            	}


HX_DEFINE_DYNAMIC_FUNC0(Geometry_obj,build,(void))

int Geometry_obj::getVerticesCount(){
            	HX_STACKFRAME(&_hx_pos_0883a6c134c4202b_394_getVerticesCount)
HXDLIN( 394)		return ::Std_obj::_hx_int((( (Float)(this->positions->self.length()) ) / ( (Float)(3) )));
            	}


HX_DEFINE_DYNAMIC_FUNC0(Geometry_obj,getVerticesCount,return )

void Geometry_obj::addArmature( ::iron::data::Armature armature){
            	HX_STACKFRAME(&_hx_pos_0883a6c134c4202b_399_addArmature)
HXDLIN( 399)		int _g = 0;
HXDLIN( 399)		::Array< ::Dynamic> _g1 = armature->actions;
HXDLIN( 399)		while((_g < _g1->length)){
HXDLIN( 399)			 ::Dynamic a = _g1->__get(_g);
HXDLIN( 399)			_g = (_g + 1);
HXLINE( 400)			this->addAction(( (::Array< ::Dynamic>)(a->__Field(HX_("bones",af,58,f7,b6),hx::paccDynamic)) ),( (::String)(a->__Field(HX_("name",4b,72,ff,48),hx::paccDynamic)) ));
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(Geometry_obj,addArmature,(void))

void Geometry_obj::addAction(::Array< ::Dynamic> bones,::String name){
            	HX_GC_STACKFRAME(&_hx_pos_0883a6c134c4202b_404_addAction)
HXLINE( 405)		if (hx::IsNull( bones )) {
HXLINE( 405)			return;
            		}
HXLINE( 406)		if (hx::IsNull( this->actions )) {
HXLINE( 407)			this->actions =  ::haxe::ds::StringMap_obj::__alloc( HX_CTX );
HXLINE( 408)			this->mats =  ::haxe::ds::StringMap_obj::__alloc( HX_CTX );
            		}
HXLINE( 410)		if (hx::IsNotNull( this->actions->get(name) )) {
HXLINE( 410)			return;
            		}
HXLINE( 411)		::Array< ::Dynamic> actionBones = ::Array_obj< ::Dynamic>::__new(0);
HXLINE( 414)		{
HXLINE( 414)			int _g = 0;
HXDLIN( 414)			::Array< ::String > _g1 = this->skeletonBoneRefs;
HXDLIN( 414)			while((_g < _g1->length)){
HXLINE( 414)				::String s = _g1->__get(_g);
HXDLIN( 414)				_g = (_g + 1);
HXLINE( 415)				{
HXLINE( 415)					int _g2 = 0;
HXDLIN( 415)					while((_g2 < bones->length)){
HXLINE( 415)						 ::iron::data::TObj b = bones->__get(_g2).StaticCast<  ::iron::data::TObj >();
HXDLIN( 415)						_g2 = (_g2 + 1);
HXLINE( 416)						if ((b->name == s)) {
HXLINE( 417)							actionBones->push(b);
            						}
            					}
            				}
            			}
            		}
HXLINE( 421)		this->actions->set(name,actionBones);
HXLINE( 423)		::Array< ::Dynamic> actionMats = ::Array_obj< ::Dynamic>::__new(0);
HXLINE( 424)		{
HXLINE( 424)			int _g3 = 0;
HXDLIN( 424)			while((_g3 < actionBones->length)){
HXLINE( 424)				 ::iron::data::TObj b1 = actionBones->__get(_g3).StaticCast<  ::iron::data::TObj >();
HXDLIN( 424)				_g3 = (_g3 + 1);
HXLINE( 425)				 ::kha::arrays::Float32ArrayPrivate a = b1->transform->values;
HXDLIN( 425)				int offset = 0;
HXDLIN( 425)				float _hx_tmp = a->self.get(offset);
HXDLIN( 425)				 float32array a1 = a->self;
HXDLIN( 425)				float _hx_tmp1 = a1.get((1 + offset));
HXDLIN( 425)				 float32array a2 = a->self;
HXDLIN( 425)				float _hx_tmp2 = a2.get((2 + offset));
HXDLIN( 425)				 float32array a3 = a->self;
HXDLIN( 425)				float _hx_tmp3 = a3.get((3 + offset));
HXDLIN( 425)				 float32array a4 = a->self;
HXDLIN( 425)				float _hx_tmp4 = a4.get((4 + offset));
HXDLIN( 425)				 float32array a5 = a->self;
HXDLIN( 425)				float _hx_tmp5 = a5.get((5 + offset));
HXDLIN( 425)				 float32array a6 = a->self;
HXDLIN( 425)				float _hx_tmp6 = a6.get((6 + offset));
HXDLIN( 425)				 float32array a7 = a->self;
HXDLIN( 425)				float _hx_tmp7 = a7.get((7 + offset));
HXDLIN( 425)				 float32array a8 = a->self;
HXDLIN( 425)				float _hx_tmp8 = a8.get((8 + offset));
HXDLIN( 425)				 float32array a9 = a->self;
HXDLIN( 425)				float _hx_tmp9 = a9.get((9 + offset));
HXDLIN( 425)				 float32array a10 = a->self;
HXDLIN( 425)				float _hx_tmp10 = a10.get((10 + offset));
HXDLIN( 425)				 float32array a11 = a->self;
HXDLIN( 425)				float _hx_tmp11 = a11.get((11 + offset));
HXDLIN( 425)				 float32array a12 = a->self;
HXDLIN( 425)				float _hx_tmp12 = a12.get((12 + offset));
HXDLIN( 425)				 float32array a13 = a->self;
HXDLIN( 425)				float _hx_tmp13 = a13.get((13 + offset));
HXDLIN( 425)				 float32array a14 = a->self;
HXDLIN( 425)				float _hx_tmp14 = a14.get((14 + offset));
HXDLIN( 425)				 float32array a15 = a->self;
HXDLIN( 425)				actionMats->push( ::iron::math::Mat4_obj::__alloc( HX_CTX ,_hx_tmp,_hx_tmp1,_hx_tmp2,_hx_tmp3,_hx_tmp4,_hx_tmp5,_hx_tmp6,_hx_tmp7,_hx_tmp8,_hx_tmp9,_hx_tmp10,_hx_tmp11,_hx_tmp12,_hx_tmp13,_hx_tmp14,a15.get((15 + offset))));
            			}
            		}
HXLINE( 427)		this->mats->set(name,actionMats);
            	}


HX_DEFINE_DYNAMIC_FUNC2(Geometry_obj,addAction,(void))

void Geometry_obj::initSkeletonTransforms(::Array< ::Dynamic> transformsI){
            	HX_GC_STACKFRAME(&_hx_pos_0883a6c134c4202b_430_initSkeletonTransforms)
HXLINE( 431)		this->skeletonTransformsI = ::Array_obj< ::Dynamic>::__new(0);
HXLINE( 436)		{
HXLINE( 436)			int _g = 0;
HXDLIN( 436)			while((_g < transformsI->length)){
HXLINE( 436)				 ::kha::arrays::Float32ArrayPrivate t = transformsI->__get(_g).StaticCast<  ::kha::arrays::Float32ArrayPrivate >();
HXDLIN( 436)				_g = (_g + 1);
HXLINE( 437)				int offset = 0;
HXDLIN( 437)				float mi = t->self.get(offset);
HXDLIN( 437)				 float32array t1 = t->self;
HXDLIN( 437)				float mi1 = t1.get((1 + offset));
HXDLIN( 437)				 float32array t2 = t->self;
HXDLIN( 437)				float mi2 = t2.get((2 + offset));
HXDLIN( 437)				 float32array t3 = t->self;
HXDLIN( 437)				float mi3 = t3.get((3 + offset));
HXDLIN( 437)				 float32array t4 = t->self;
HXDLIN( 437)				float mi4 = t4.get((4 + offset));
HXDLIN( 437)				 float32array t5 = t->self;
HXDLIN( 437)				float mi5 = t5.get((5 + offset));
HXDLIN( 437)				 float32array t6 = t->self;
HXDLIN( 437)				float mi6 = t6.get((6 + offset));
HXDLIN( 437)				 float32array t7 = t->self;
HXDLIN( 437)				float mi7 = t7.get((7 + offset));
HXDLIN( 437)				 float32array t8 = t->self;
HXDLIN( 437)				float mi8 = t8.get((8 + offset));
HXDLIN( 437)				 float32array t9 = t->self;
HXDLIN( 437)				float mi9 = t9.get((9 + offset));
HXDLIN( 437)				 float32array t10 = t->self;
HXDLIN( 437)				float mi10 = t10.get((10 + offset));
HXDLIN( 437)				 float32array t11 = t->self;
HXDLIN( 437)				float mi11 = t11.get((11 + offset));
HXDLIN( 437)				 float32array t12 = t->self;
HXDLIN( 437)				float mi12 = t12.get((12 + offset));
HXDLIN( 437)				 float32array t13 = t->self;
HXDLIN( 437)				float mi13 = t13.get((13 + offset));
HXDLIN( 437)				 float32array t14 = t->self;
HXDLIN( 437)				float mi14 = t14.get((14 + offset));
HXDLIN( 437)				 float32array t15 = t->self;
HXDLIN( 437)				 ::iron::math::Mat4 mi15 =  ::iron::math::Mat4_obj::__alloc( HX_CTX ,mi,mi1,mi2,mi3,mi4,mi5,mi6,mi7,mi8,mi9,mi10,mi11,mi12,mi13,mi14,t15.get((15 + offset)));
HXLINE( 438)				this->skeletonTransformsI->push(mi15);
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(Geometry_obj,initSkeletonTransforms,(void))

void Geometry_obj::calculateAABB(){
            	HX_GC_STACKFRAME(&_hx_pos_0883a6c134c4202b_457_calculateAABB)
HXLINE( 458)		float aabbMin_x = ( (float)(((Float)-0.01)) );
HXDLIN( 458)		float aabbMin_y = ( (float)(((Float)-0.01)) );
HXDLIN( 458)		float aabbMin_z = ( (float)(((Float)-0.01)) );
HXDLIN( 458)		float aabbMin_w = ( (float)(((Float)1.0)) );
HXLINE( 459)		float aabbMax_x = ( (float)(((Float)0.01)) );
HXDLIN( 459)		float aabbMax_y = ( (float)(((Float)0.01)) );
HXDLIN( 459)		float aabbMax_z = ( (float)(((Float)0.01)) );
HXDLIN( 459)		float aabbMax_w = ( (float)(((Float)1.0)) );
HXLINE( 460)		this->aabb =  ::iron::math::Vec4_obj::__alloc( HX_CTX ,null(),null(),null(),null());
HXLINE( 461)		int i = 0;
HXLINE( 462)		while((i < this->positions->self.length())){
HXLINE( 463)			if ((this->positions->self.get(i) > aabbMax_x)) {
HXLINE( 463)				aabbMax_x = this->positions->self.get(i);
            			}
HXLINE( 464)			 float32array this1 = this->positions->self;
HXDLIN( 464)			if ((this1.get((i + 1)) > aabbMax_y)) {
HXLINE( 464)				 float32array this2 = this->positions->self;
HXDLIN( 464)				aabbMax_y = this2.get((i + 1));
            			}
HXLINE( 465)			 float32array this3 = this->positions->self;
HXDLIN( 465)			if ((this3.get((i + 2)) > aabbMax_z)) {
HXLINE( 465)				 float32array this4 = this->positions->self;
HXDLIN( 465)				aabbMax_z = this4.get((i + 2));
            			}
HXLINE( 466)			if ((this->positions->self.get(i) < aabbMin_x)) {
HXLINE( 466)				aabbMin_x = this->positions->self.get(i);
            			}
HXLINE( 467)			 float32array this5 = this->positions->self;
HXDLIN( 467)			if ((this5.get((i + 1)) < aabbMin_y)) {
HXLINE( 467)				 float32array this6 = this->positions->self;
HXDLIN( 467)				aabbMin_y = this6.get((i + 1));
            			}
HXLINE( 468)			 float32array this7 = this->positions->self;
HXDLIN( 468)			if ((this7.get((i + 2)) < aabbMin_z)) {
HXLINE( 468)				 float32array this8 = this->positions->self;
HXDLIN( 468)				aabbMin_z = this8.get((i + 2));
            			}
HXLINE( 469)			i = (i + 3);
            		}
HXLINE( 471)		Float _hx_tmp = ::Math_obj::abs(( (Float)(aabbMin_x) ));
HXDLIN( 471)		this->aabb->x = ( (float)((_hx_tmp + ::Math_obj::abs(( (Float)(aabbMax_x) )))) );
HXLINE( 472)		Float _hx_tmp1 = ::Math_obj::abs(( (Float)(aabbMin_y) ));
HXDLIN( 472)		this->aabb->y = ( (float)((_hx_tmp1 + ::Math_obj::abs(( (Float)(aabbMax_y) )))) );
HXLINE( 473)		Float _hx_tmp2 = ::Math_obj::abs(( (Float)(aabbMin_z) ));
HXDLIN( 473)		this->aabb->z = ( (float)((_hx_tmp2 + ::Math_obj::abs(( (Float)(aabbMax_z) )))) );
            	}


HX_DEFINE_DYNAMIC_FUNC0(Geometry_obj,calculateAABB,(void))

 ::kha::graphics4::VertexStructure Geometry_obj::getVertexStructure(hx::Null< bool >  __o_pos,hx::Null< bool >  __o_nor,hx::Null< bool >  __o_tex,hx::Null< bool >  __o_tex1,hx::Null< bool >  __o_col,hx::Null< bool >  __o_tang,hx::Null< bool >  __o_bone,hx::Null< bool >  __o_weight){
bool pos = __o_pos.Default(false);
bool nor = __o_nor.Default(false);
bool tex = __o_tex.Default(false);
bool tex1 = __o_tex1.Default(false);
bool col = __o_col.Default(false);
bool tang = __o_tang.Default(false);
bool bone = __o_bone.Default(false);
bool weight = __o_weight.Default(false);
            	HX_GC_STACKFRAME(&_hx_pos_0883a6c134c4202b_118_getVertexStructure)
HXLINE( 119)		 ::kha::graphics4::VertexStructure structure =  ::kha::graphics4::VertexStructure_obj::__alloc( HX_CTX );
HXLINE( 120)		if (pos) {
HXLINE( 120)			structure->add(HX_("pos",94,5d,55,00),2);
            		}
HXLINE( 121)		if (nor) {
HXLINE( 121)			structure->add(HX_("nor",11,d9,53,00),2);
            		}
HXLINE( 122)		if (tex) {
HXLINE( 122)			structure->add(HX_("tex",e7,5d,58,00),1);
            		}
HXLINE( 123)		if (tex1) {
HXLINE( 123)			structure->add(HX_("tex1",6a,cc,f9,4c),1);
            		}
HXLINE( 124)		if (col) {
HXLINE( 124)			structure->add(HX_("col",40,80,4b,00),2);
            		}
HXLINE( 125)		if (tang) {
HXLINE( 125)			structure->add(HX_("tang",e6,ba,f6,4c),2);
            		}
HXLINE( 126)		if (bone) {
HXLINE( 126)			structure->add(HX_("bone",44,83,1b,41),3);
            		}
HXLINE( 127)		if (weight) {
HXLINE( 127)			structure->add(HX_("weight",78,71,a6,01),3);
            		}
HXLINE( 128)		return structure;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC8(Geometry_obj,getVertexStructure,return )

void Geometry_obj::buildVertices( ::kha::arrays::Float32ArrayPrivate vertices, ::kha::arrays::Float32ArrayPrivate pa, ::kha::arrays::Float32ArrayPrivate na, ::kha::arrays::Float32ArrayPrivate uva, ::kha::arrays::Float32ArrayPrivate uva1, ::kha::arrays::Float32ArrayPrivate ca, ::kha::arrays::Float32ArrayPrivate tanga, ::kha::arrays::Float32ArrayPrivate bonea, ::kha::arrays::Float32ArrayPrivate weighta,hx::Null< int >  __o_offset,hx::Null< bool >  __o_fakeUVs){
int offset = __o_offset.Default(0);
bool fakeUVs = __o_fakeUVs.Default(false);
            	HX_STACKFRAME(&_hx_pos_0883a6c134c4202b_213_buildVertices)
HXLINE( 215)		int numVertices = ::Std_obj::_hx_int((( (Float)(pa->self.length()) ) / ( (Float)(3) )));
HXLINE( 216)		int di = (-1 + offset);
HXLINE( 217)		{
HXLINE( 217)			int _g1 = 0;
HXDLIN( 217)			int _g = numVertices;
HXDLIN( 217)			while((_g1 < _g)){
HXLINE( 217)				_g1 = (_g1 + 1);
HXDLIN( 217)				int i = (_g1 - 1);
HXLINE( 218)				{
HXLINE( 218)					di = (di + 1);
HXDLIN( 218)					 float32array pa1 = pa->self;
HXDLIN( 218)					float value = pa1.get((i * 3));
HXDLIN( 218)					vertices->self.set(di,value);
            				}
HXLINE( 219)				{
HXLINE( 219)					di = (di + 1);
HXDLIN( 219)					 float32array pa2 = pa->self;
HXDLIN( 219)					float value1 = pa2.get(((i * 3) + 1));
HXDLIN( 219)					vertices->self.set(di,value1);
            				}
HXLINE( 220)				{
HXLINE( 220)					di = (di + 1);
HXDLIN( 220)					 float32array pa3 = pa->self;
HXDLIN( 220)					float value2 = pa3.get(((i * 3) + 2));
HXDLIN( 220)					vertices->self.set(di,value2);
            				}
HXLINE( 222)				if (hx::IsNotNull( na )) {
HXLINE( 223)					{
HXLINE( 223)						di = (di + 1);
HXDLIN( 223)						 float32array na1 = na->self;
HXDLIN( 223)						float value3 = na1.get((i * 3));
HXDLIN( 223)						vertices->self.set(di,value3);
            					}
HXLINE( 224)					{
HXLINE( 224)						di = (di + 1);
HXDLIN( 224)						 float32array na2 = na->self;
HXDLIN( 224)						float value4 = na2.get(((i * 3) + 1));
HXDLIN( 224)						vertices->self.set(di,value4);
            					}
HXLINE( 225)					{
HXLINE( 225)						di = (di + 1);
HXDLIN( 225)						 float32array na3 = na->self;
HXDLIN( 225)						float value5 = na3.get(((i * 3) + 2));
HXDLIN( 225)						vertices->self.set(di,value5);
            					}
            				}
HXLINE( 227)				if (hx::IsNotNull( uva )) {
HXLINE( 228)					{
HXLINE( 228)						di = (di + 1);
HXDLIN( 228)						 float32array uva2 = uva->self;
HXDLIN( 228)						float value6 = uva2.get((i * 2));
HXDLIN( 228)						vertices->self.set(di,value6);
            					}
HXLINE( 229)					{
HXLINE( 229)						di = (di + 1);
HXDLIN( 229)						 float32array uva3 = uva->self;
HXDLIN( 229)						float value7 = uva3.get(((i * 2) + 1));
HXDLIN( 229)						vertices->self.set(di,value7);
            					}
            				}
            				else {
HXLINE( 231)					if (fakeUVs) {
HXLINE( 232)						{
HXLINE( 232)							di = (di + 1);
HXDLIN( 232)							vertices->self.set(di,( (float)(((Float)0.0)) ));
            						}
HXLINE( 233)						{
HXLINE( 233)							di = (di + 1);
HXDLIN( 233)							vertices->self.set(di,( (float)(((Float)0.0)) ));
            						}
            					}
            				}
HXLINE( 235)				if (hx::IsNotNull( uva1 )) {
HXLINE( 236)					{
HXLINE( 236)						di = (di + 1);
HXDLIN( 236)						 float32array uva11 = uva1->self;
HXDLIN( 236)						float value8 = uva11.get((i * 2));
HXDLIN( 236)						vertices->self.set(di,value8);
            					}
HXLINE( 237)					{
HXLINE( 237)						di = (di + 1);
HXDLIN( 237)						 float32array uva12 = uva1->self;
HXDLIN( 237)						float value9 = uva12.get(((i * 2) + 1));
HXDLIN( 237)						vertices->self.set(di,value9);
            					}
            				}
HXLINE( 239)				if (hx::IsNotNull( ca )) {
HXLINE( 240)					{
HXLINE( 240)						di = (di + 1);
HXDLIN( 240)						 float32array ca1 = ca->self;
HXDLIN( 240)						float value10 = ca1.get((i * 3));
HXDLIN( 240)						vertices->self.set(di,value10);
            					}
HXLINE( 241)					{
HXLINE( 241)						di = (di + 1);
HXDLIN( 241)						 float32array ca2 = ca->self;
HXDLIN( 241)						float value11 = ca2.get(((i * 3) + 1));
HXDLIN( 241)						vertices->self.set(di,value11);
            					}
HXLINE( 242)					{
HXLINE( 242)						di = (di + 1);
HXDLIN( 242)						 float32array ca3 = ca->self;
HXDLIN( 242)						float value12 = ca3.get(((i * 3) + 2));
HXDLIN( 242)						vertices->self.set(di,value12);
            					}
            				}
HXLINE( 245)				if (hx::IsNotNull( tanga )) {
HXLINE( 246)					{
HXLINE( 246)						di = (di + 1);
HXDLIN( 246)						 float32array tanga1 = tanga->self;
HXDLIN( 246)						float value13 = tanga1.get((i * 3));
HXDLIN( 246)						vertices->self.set(di,value13);
            					}
HXLINE( 247)					{
HXLINE( 247)						di = (di + 1);
HXDLIN( 247)						 float32array tanga2 = tanga->self;
HXDLIN( 247)						float value14 = tanga2.get(((i * 3) + 1));
HXDLIN( 247)						vertices->self.set(di,value14);
            					}
HXLINE( 248)					{
HXLINE( 248)						di = (di + 1);
HXDLIN( 248)						 float32array tanga3 = tanga->self;
HXDLIN( 248)						float value15 = tanga3.get(((i * 3) + 2));
HXDLIN( 248)						vertices->self.set(di,value15);
            					}
            				}
HXLINE( 251)				if (hx::IsNotNull( bonea )) {
HXLINE( 252)					{
HXLINE( 252)						di = (di + 1);
HXDLIN( 252)						 float32array bonea1 = bonea->self;
HXDLIN( 252)						float value16 = bonea1.get((i * 4));
HXDLIN( 252)						vertices->self.set(di,value16);
            					}
HXLINE( 253)					{
HXLINE( 253)						di = (di + 1);
HXDLIN( 253)						 float32array bonea2 = bonea->self;
HXDLIN( 253)						float value17 = bonea2.get(((i * 4) + 1));
HXDLIN( 253)						vertices->self.set(di,value17);
            					}
HXLINE( 254)					{
HXLINE( 254)						di = (di + 1);
HXDLIN( 254)						 float32array bonea3 = bonea->self;
HXDLIN( 254)						float value18 = bonea3.get(((i * 4) + 2));
HXDLIN( 254)						vertices->self.set(di,value18);
            					}
HXLINE( 255)					{
HXLINE( 255)						di = (di + 1);
HXDLIN( 255)						 float32array bonea4 = bonea->self;
HXDLIN( 255)						float value19 = bonea4.get(((i * 4) + 3));
HXDLIN( 255)						vertices->self.set(di,value19);
            					}
            				}
HXLINE( 257)				if (hx::IsNotNull( weighta )) {
HXLINE( 258)					{
HXLINE( 258)						di = (di + 1);
HXDLIN( 258)						 float32array weighta1 = weighta->self;
HXDLIN( 258)						float value20 = weighta1.get((i * 4));
HXDLIN( 258)						vertices->self.set(di,value20);
            					}
HXLINE( 259)					{
HXLINE( 259)						di = (di + 1);
HXDLIN( 259)						 float32array weighta2 = weighta->self;
HXDLIN( 259)						float value21 = weighta2.get(((i * 4) + 1));
HXDLIN( 259)						vertices->self.set(di,value21);
            					}
HXLINE( 260)					{
HXLINE( 260)						di = (di + 1);
HXDLIN( 260)						 float32array weighta3 = weighta->self;
HXDLIN( 260)						float value22 = weighta3.get(((i * 4) + 2));
HXDLIN( 260)						vertices->self.set(di,value22);
            					}
HXLINE( 261)					{
HXLINE( 261)						di = (di + 1);
HXDLIN( 261)						 float32array weighta4 = weighta->self;
HXDLIN( 261)						float value23 = weighta4.get(((i * 4) + 3));
HXDLIN( 261)						vertices->self.set(di,value23);
            					}
            				}
            			}
            		}
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC11(Geometry_obj,buildVertices,(void))


hx::ObjectPtr< Geometry_obj > Geometry_obj::__new(::Array< ::Dynamic> indices,::Array< int > materialIndices, ::kha::arrays::Float32ArrayPrivate positions, ::kha::arrays::Float32ArrayPrivate normals, ::kha::arrays::Float32ArrayPrivate uvs, ::kha::arrays::Float32ArrayPrivate uvs1, ::kha::arrays::Float32ArrayPrivate cols, ::kha::arrays::Float32ArrayPrivate tangents, ::kha::arrays::Float32ArrayPrivate bones, ::kha::arrays::Float32ArrayPrivate weights, ::kha::graphics4::Usage usage, ::kha::arrays::Float32ArrayPrivate instancedData, ::Dynamic instancedType) {
	hx::ObjectPtr< Geometry_obj > __this = new Geometry_obj();
	__this->__construct(indices,materialIndices,positions,normals,uvs,uvs1,cols,tangents,bones,weights,usage,instancedData,instancedType);
	return __this;
}

hx::ObjectPtr< Geometry_obj > Geometry_obj::__alloc(hx::Ctx *_hx_ctx,::Array< ::Dynamic> indices,::Array< int > materialIndices, ::kha::arrays::Float32ArrayPrivate positions, ::kha::arrays::Float32ArrayPrivate normals, ::kha::arrays::Float32ArrayPrivate uvs, ::kha::arrays::Float32ArrayPrivate uvs1, ::kha::arrays::Float32ArrayPrivate cols, ::kha::arrays::Float32ArrayPrivate tangents, ::kha::arrays::Float32ArrayPrivate bones, ::kha::arrays::Float32ArrayPrivate weights, ::kha::graphics4::Usage usage, ::kha::arrays::Float32ArrayPrivate instancedData, ::Dynamic instancedType) {
	Geometry_obj *__this = (Geometry_obj*)(hx::Ctx::alloc(_hx_ctx, sizeof(Geometry_obj), true, "iron.data.Geometry"));
	*(void **)__this = Geometry_obj::_hx_vtable;
	__this->__construct(indices,materialIndices,positions,normals,uvs,uvs1,cols,tangents,bones,weights,usage,instancedData,instancedType);
	return __this;
}

Geometry_obj::Geometry_obj()
{
}

void Geometry_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(Geometry);
	HX_MARK_MEMBER_NAME(vertexBuffer,"vertexBuffer");
	HX_MARK_MEMBER_NAME(vertexBufferMap,"vertexBufferMap");
	HX_MARK_MEMBER_NAME(indexBuffers,"indexBuffers");
	HX_MARK_MEMBER_NAME(start,"start");
	HX_MARK_MEMBER_NAME(count,"count");
	HX_MARK_MEMBER_NAME(name,"name");
	HX_MARK_MEMBER_NAME(ready,"ready");
	HX_MARK_MEMBER_NAME(vertices,"vertices");
	HX_MARK_MEMBER_NAME(indices,"indices");
	HX_MARK_MEMBER_NAME(numTris,"numTris");
	HX_MARK_MEMBER_NAME(materialIndices,"materialIndices");
	HX_MARK_MEMBER_NAME(_hx_struct,"struct");
	HX_MARK_MEMBER_NAME(structLength,"structLength");
	HX_MARK_MEMBER_NAME(structStr,"structStr");
	HX_MARK_MEMBER_NAME(usage,"usage");
	HX_MARK_MEMBER_NAME(instancedVB,"instancedVB");
	HX_MARK_MEMBER_NAME(instanced,"instanced");
	HX_MARK_MEMBER_NAME(instanceCount,"instanceCount");
	HX_MARK_MEMBER_NAME(positions,"positions");
	HX_MARK_MEMBER_NAME(normals,"normals");
	HX_MARK_MEMBER_NAME(uvs,"uvs");
	HX_MARK_MEMBER_NAME(uvs1,"uvs1");
	HX_MARK_MEMBER_NAME(cols,"cols");
	HX_MARK_MEMBER_NAME(tangents,"tangents");
	HX_MARK_MEMBER_NAME(bones,"bones");
	HX_MARK_MEMBER_NAME(weights,"weights");
	HX_MARK_MEMBER_NAME(instancedData,"instancedData");
	HX_MARK_MEMBER_NAME(instancedType,"instancedType");
	HX_MARK_MEMBER_NAME(aabb,"aabb");
	HX_MARK_MEMBER_NAME(skinBoneCounts,"skinBoneCounts");
	HX_MARK_MEMBER_NAME(skinBoneIndices,"skinBoneIndices");
	HX_MARK_MEMBER_NAME(skinBoneWeights,"skinBoneWeights");
	HX_MARK_MEMBER_NAME(skeletonTransformsI,"skeletonTransformsI");
	HX_MARK_MEMBER_NAME(skeletonBoneRefs,"skeletonBoneRefs");
	HX_MARK_MEMBER_NAME(skeletonBoneLens,"skeletonBoneLens");
	HX_MARK_MEMBER_NAME(actions,"actions");
	HX_MARK_MEMBER_NAME(mats,"mats");
	HX_MARK_END_CLASS();
}

void Geometry_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(vertexBuffer,"vertexBuffer");
	HX_VISIT_MEMBER_NAME(vertexBufferMap,"vertexBufferMap");
	HX_VISIT_MEMBER_NAME(indexBuffers,"indexBuffers");
	HX_VISIT_MEMBER_NAME(start,"start");
	HX_VISIT_MEMBER_NAME(count,"count");
	HX_VISIT_MEMBER_NAME(name,"name");
	HX_VISIT_MEMBER_NAME(ready,"ready");
	HX_VISIT_MEMBER_NAME(vertices,"vertices");
	HX_VISIT_MEMBER_NAME(indices,"indices");
	HX_VISIT_MEMBER_NAME(numTris,"numTris");
	HX_VISIT_MEMBER_NAME(materialIndices,"materialIndices");
	HX_VISIT_MEMBER_NAME(_hx_struct,"struct");
	HX_VISIT_MEMBER_NAME(structLength,"structLength");
	HX_VISIT_MEMBER_NAME(structStr,"structStr");
	HX_VISIT_MEMBER_NAME(usage,"usage");
	HX_VISIT_MEMBER_NAME(instancedVB,"instancedVB");
	HX_VISIT_MEMBER_NAME(instanced,"instanced");
	HX_VISIT_MEMBER_NAME(instanceCount,"instanceCount");
	HX_VISIT_MEMBER_NAME(positions,"positions");
	HX_VISIT_MEMBER_NAME(normals,"normals");
	HX_VISIT_MEMBER_NAME(uvs,"uvs");
	HX_VISIT_MEMBER_NAME(uvs1,"uvs1");
	HX_VISIT_MEMBER_NAME(cols,"cols");
	HX_VISIT_MEMBER_NAME(tangents,"tangents");
	HX_VISIT_MEMBER_NAME(bones,"bones");
	HX_VISIT_MEMBER_NAME(weights,"weights");
	HX_VISIT_MEMBER_NAME(instancedData,"instancedData");
	HX_VISIT_MEMBER_NAME(instancedType,"instancedType");
	HX_VISIT_MEMBER_NAME(aabb,"aabb");
	HX_VISIT_MEMBER_NAME(skinBoneCounts,"skinBoneCounts");
	HX_VISIT_MEMBER_NAME(skinBoneIndices,"skinBoneIndices");
	HX_VISIT_MEMBER_NAME(skinBoneWeights,"skinBoneWeights");
	HX_VISIT_MEMBER_NAME(skeletonTransformsI,"skeletonTransformsI");
	HX_VISIT_MEMBER_NAME(skeletonBoneRefs,"skeletonBoneRefs");
	HX_VISIT_MEMBER_NAME(skeletonBoneLens,"skeletonBoneLens");
	HX_VISIT_MEMBER_NAME(actions,"actions");
	HX_VISIT_MEMBER_NAME(mats,"mats");
}

hx::Val Geometry_obj::__Field(const ::String &inName,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 3:
		if (HX_FIELD_EQ(inName,"uvs") ) { return hx::Val( uvs ); }
		if (HX_FIELD_EQ(inName,"get") ) { return hx::Val( get_dyn() ); }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"name") ) { return hx::Val( name ); }
		if (HX_FIELD_EQ(inName,"uvs1") ) { return hx::Val( uvs1 ); }
		if (HX_FIELD_EQ(inName,"cols") ) { return hx::Val( cols ); }
		if (HX_FIELD_EQ(inName,"aabb") ) { return hx::Val( aabb ); }
		if (HX_FIELD_EQ(inName,"mats") ) { return hx::Val( mats ); }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"start") ) { return hx::Val( start ); }
		if (HX_FIELD_EQ(inName,"count") ) { return hx::Val( count ); }
		if (HX_FIELD_EQ(inName,"ready") ) { return hx::Val( ready ); }
		if (HX_FIELD_EQ(inName,"usage") ) { return hx::Val( usage ); }
		if (HX_FIELD_EQ(inName,"bones") ) { return hx::Val( bones ); }
		if (HX_FIELD_EQ(inName,"build") ) { return hx::Val( build_dyn() ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"struct") ) { return hx::Val( _hx_struct ); }
		if (HX_FIELD_EQ(inName,"delete") ) { return hx::Val( _hx_delete_dyn() ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"indices") ) { return hx::Val( indices ); }
		if (HX_FIELD_EQ(inName,"numTris") ) { return hx::Val( numTris ); }
		if (HX_FIELD_EQ(inName,"normals") ) { return hx::Val( normals ); }
		if (HX_FIELD_EQ(inName,"weights") ) { return hx::Val( weights ); }
		if (HX_FIELD_EQ(inName,"actions") ) { return hx::Val( actions ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"vertices") ) { return hx::Val( vertices ); }
		if (HX_FIELD_EQ(inName,"tangents") ) { return hx::Val( tangents ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"structStr") ) { return hx::Val( structStr ); }
		if (HX_FIELD_EQ(inName,"instanced") ) { return hx::Val( instanced ); }
		if (HX_FIELD_EQ(inName,"positions") ) { return hx::Val( positions ); }
		if (HX_FIELD_EQ(inName,"hasAttrib") ) { return hx::Val( hasAttrib_dyn() ); }
		if (HX_FIELD_EQ(inName,"addAction") ) { return hx::Val( addAction_dyn() ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"applyScale") ) { return hx::Val( applyScale_dyn() ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"instancedVB") ) { return hx::Val( instancedVB ); }
		if (HX_FIELD_EQ(inName,"addArmature") ) { return hx::Val( addArmature_dyn() ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"vertexBuffer") ) { return hx::Val( vertexBuffer ); }
		if (HX_FIELD_EQ(inName,"indexBuffers") ) { return hx::Val( indexBuffers ); }
		if (HX_FIELD_EQ(inName,"structLength") ) { return hx::Val( structLength ); }
		if (HX_FIELD_EQ(inName,"copyVertices") ) { return hx::Val( copyVertices_dyn() ); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"instanceCount") ) { return hx::Val( instanceCount ); }
		if (HX_FIELD_EQ(inName,"instancedData") ) { return hx::Val( instancedData ); }
		if (HX_FIELD_EQ(inName,"instancedType") ) { return hx::Val( instancedType ); }
		if (HX_FIELD_EQ(inName,"calculateAABB") ) { return hx::Val( calculateAABB_dyn() ); }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"skinBoneCounts") ) { return hx::Val( skinBoneCounts ); }
		if (HX_FIELD_EQ(inName,"setupInstanced") ) { return hx::Val( setupInstanced_dyn() ); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"vertexBufferMap") ) { return hx::Val( vertexBufferMap ); }
		if (HX_FIELD_EQ(inName,"materialIndices") ) { return hx::Val( materialIndices ); }
		if (HX_FIELD_EQ(inName,"skinBoneIndices") ) { return hx::Val( skinBoneIndices ); }
		if (HX_FIELD_EQ(inName,"skinBoneWeights") ) { return hx::Val( skinBoneWeights ); }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"skeletonBoneRefs") ) { return hx::Val( skeletonBoneRefs ); }
		if (HX_FIELD_EQ(inName,"skeletonBoneLens") ) { return hx::Val( skeletonBoneLens ); }
		if (HX_FIELD_EQ(inName,"getVerticesCount") ) { return hx::Val( getVerticesCount_dyn() ); }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"getVerticesLength") ) { return hx::Val( getVerticesLength_dyn() ); }
		break;
	case 19:
		if (HX_FIELD_EQ(inName,"skeletonTransformsI") ) { return hx::Val( skeletonTransformsI ); }
		break;
	case 22:
		if (HX_FIELD_EQ(inName,"initSkeletonTransforms") ) { return hx::Val( initSkeletonTransforms_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

bool Geometry_obj::__GetStatic(const ::String &inName, Dynamic &outValue, hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 13:
		if (HX_FIELD_EQ(inName,"buildVertices") ) { outValue = buildVertices_dyn(); return true; }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"getVertexStructure") ) { outValue = getVertexStructure_dyn(); return true; }
	}
	return false;
}

hx::Val Geometry_obj::__SetField(const ::String &inName,const hx::Val &inValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 3:
		if (HX_FIELD_EQ(inName,"uvs") ) { uvs=inValue.Cast<  ::kha::arrays::Float32ArrayPrivate >(); return inValue; }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"name") ) { name=inValue.Cast< ::String >(); return inValue; }
		if (HX_FIELD_EQ(inName,"uvs1") ) { uvs1=inValue.Cast<  ::kha::arrays::Float32ArrayPrivate >(); return inValue; }
		if (HX_FIELD_EQ(inName,"cols") ) { cols=inValue.Cast<  ::kha::arrays::Float32ArrayPrivate >(); return inValue; }
		if (HX_FIELD_EQ(inName,"aabb") ) { aabb=inValue.Cast<  ::iron::math::Vec4 >(); return inValue; }
		if (HX_FIELD_EQ(inName,"mats") ) { mats=inValue.Cast<  ::haxe::ds::StringMap >(); return inValue; }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"start") ) { start=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"count") ) { count=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"ready") ) { ready=inValue.Cast< bool >(); return inValue; }
		if (HX_FIELD_EQ(inName,"usage") ) { usage=inValue.Cast<  ::kha::graphics4::Usage >(); return inValue; }
		if (HX_FIELD_EQ(inName,"bones") ) { bones=inValue.Cast<  ::kha::arrays::Float32ArrayPrivate >(); return inValue; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"struct") ) { _hx_struct=inValue.Cast<  ::kha::graphics4::VertexStructure >(); return inValue; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"indices") ) { indices=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		if (HX_FIELD_EQ(inName,"numTris") ) { numTris=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"normals") ) { normals=inValue.Cast<  ::kha::arrays::Float32ArrayPrivate >(); return inValue; }
		if (HX_FIELD_EQ(inName,"weights") ) { weights=inValue.Cast<  ::kha::arrays::Float32ArrayPrivate >(); return inValue; }
		if (HX_FIELD_EQ(inName,"actions") ) { actions=inValue.Cast<  ::haxe::ds::StringMap >(); return inValue; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"vertices") ) { vertices=inValue.Cast<  ::kha::arrays::Float32ArrayPrivate >(); return inValue; }
		if (HX_FIELD_EQ(inName,"tangents") ) { tangents=inValue.Cast<  ::kha::arrays::Float32ArrayPrivate >(); return inValue; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"structStr") ) { structStr=inValue.Cast< ::String >(); return inValue; }
		if (HX_FIELD_EQ(inName,"instanced") ) { instanced=inValue.Cast< bool >(); return inValue; }
		if (HX_FIELD_EQ(inName,"positions") ) { positions=inValue.Cast<  ::kha::arrays::Float32ArrayPrivate >(); return inValue; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"instancedVB") ) { instancedVB=inValue.Cast<  ::kha::graphics4::VertexBuffer >(); return inValue; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"vertexBuffer") ) { vertexBuffer=inValue.Cast<  ::kha::graphics4::VertexBuffer >(); return inValue; }
		if (HX_FIELD_EQ(inName,"indexBuffers") ) { indexBuffers=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		if (HX_FIELD_EQ(inName,"structLength") ) { structLength=inValue.Cast< int >(); return inValue; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"instanceCount") ) { instanceCount=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"instancedData") ) { instancedData=inValue.Cast<  ::kha::arrays::Float32ArrayPrivate >(); return inValue; }
		if (HX_FIELD_EQ(inName,"instancedType") ) { instancedType=inValue.Cast<  ::Dynamic >(); return inValue; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"skinBoneCounts") ) { skinBoneCounts=inValue.Cast<  ::kha::arrays::Uint32ArrayPrivate >(); return inValue; }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"vertexBufferMap") ) { vertexBufferMap=inValue.Cast<  ::haxe::ds::StringMap >(); return inValue; }
		if (HX_FIELD_EQ(inName,"materialIndices") ) { materialIndices=inValue.Cast< ::Array< int > >(); return inValue; }
		if (HX_FIELD_EQ(inName,"skinBoneIndices") ) { skinBoneIndices=inValue.Cast<  ::kha::arrays::Uint32ArrayPrivate >(); return inValue; }
		if (HX_FIELD_EQ(inName,"skinBoneWeights") ) { skinBoneWeights=inValue.Cast<  ::kha::arrays::Float32ArrayPrivate >(); return inValue; }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"skeletonBoneRefs") ) { skeletonBoneRefs=inValue.Cast< ::Array< ::String > >(); return inValue; }
		if (HX_FIELD_EQ(inName,"skeletonBoneLens") ) { skeletonBoneLens=inValue.Cast<  ::kha::arrays::Float32ArrayPrivate >(); return inValue; }
		break;
	case 19:
		if (HX_FIELD_EQ(inName,"skeletonTransformsI") ) { skeletonTransformsI=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void Geometry_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("vertexBuffer",84,af,a9,70));
	outFields->push(HX_("vertexBufferMap",78,9d,c8,a2));
	outFields->push(HX_("indexBuffers",81,96,f2,fb));
	outFields->push(HX_("start",62,74,0b,84));
	outFields->push(HX_("count",cf,44,63,4a));
	outFields->push(HX_("name",4b,72,ff,48));
	outFields->push(HX_("ready",63,a0,ba,e6));
	outFields->push(HX_("vertices",f9,bf,15,6a));
	outFields->push(HX_("indices",27,47,54,e3));
	outFields->push(HX_("numTris",4e,42,84,a0));
	outFields->push(HX_("materialIndices",40,05,8c,bf));
	outFields->push(HX_("struct",55,3a,39,11));
	outFields->push(HX_("structLength",1b,31,1d,c1));
	outFields->push(HX_("structStr",5c,89,35,47));
	outFields->push(HX_("usage",21,5d,2f,aa));
	outFields->push(HX_("instancedVB",1b,38,25,29));
	outFields->push(HX_("instanced",2f,83,1a,4b));
	outFields->push(HX_("instanceCount",fa,f8,6b,b7));
	outFields->push(HX_("positions",aa,f3,51,d0));
	outFields->push(HX_("normals",6c,70,da,2b));
	outFields->push(HX_("uvs",f2,2e,59,00));
	outFields->push(HX_("uvs1",ff,e4,af,4d));
	outFields->push(HX_("cols",33,b8,c4,41));
	outFields->push(HX_("tangents",0e,90,1b,39));
	outFields->push(HX_("bones",af,58,f7,b6));
	outFields->push(HX_("weights",fb,d7,fc,6f));
	outFields->push(HX_("instancedData",f9,c8,29,9b));
	outFields->push(HX_("instancedType",89,65,cf,a5));
	outFields->push(HX_("aabb",a0,a2,67,40));
	outFields->push(HX_("skinBoneCounts",05,ac,f8,f8));
	outFields->push(HX_("skinBoneIndices",c6,64,98,a6));
	outFields->push(HX_("skinBoneWeights",9a,f5,40,33));
	outFields->push(HX_("skeletonTransformsI",15,d4,ac,3a));
	outFields->push(HX_("skeletonBoneRefs",11,b4,c3,74));
	outFields->push(HX_("skeletonBoneLens",4f,73,cc,70));
	outFields->push(HX_("actions",fd,03,2e,67));
	outFields->push(HX_("mats",d3,41,56,48));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static hx::StorageInfo Geometry_obj_sMemberStorageInfo[] = {
	{hx::fsObject /*::kha::graphics4::VertexBuffer*/ ,(int)offsetof(Geometry_obj,vertexBuffer),HX_("vertexBuffer",84,af,a9,70)},
	{hx::fsObject /*::haxe::ds::StringMap*/ ,(int)offsetof(Geometry_obj,vertexBufferMap),HX_("vertexBufferMap",78,9d,c8,a2)},
	{hx::fsObject /*Array< ::Dynamic >*/ ,(int)offsetof(Geometry_obj,indexBuffers),HX_("indexBuffers",81,96,f2,fb)},
	{hx::fsInt,(int)offsetof(Geometry_obj,start),HX_("start",62,74,0b,84)},
	{hx::fsInt,(int)offsetof(Geometry_obj,count),HX_("count",cf,44,63,4a)},
	{hx::fsString,(int)offsetof(Geometry_obj,name),HX_("name",4b,72,ff,48)},
	{hx::fsBool,(int)offsetof(Geometry_obj,ready),HX_("ready",63,a0,ba,e6)},
	{hx::fsObject /*::kha::arrays::Float32ArrayPrivate*/ ,(int)offsetof(Geometry_obj,vertices),HX_("vertices",f9,bf,15,6a)},
	{hx::fsObject /*Array< ::Dynamic >*/ ,(int)offsetof(Geometry_obj,indices),HX_("indices",27,47,54,e3)},
	{hx::fsInt,(int)offsetof(Geometry_obj,numTris),HX_("numTris",4e,42,84,a0)},
	{hx::fsObject /*Array< int >*/ ,(int)offsetof(Geometry_obj,materialIndices),HX_("materialIndices",40,05,8c,bf)},
	{hx::fsObject /*::kha::graphics4::VertexStructure*/ ,(int)offsetof(Geometry_obj,_hx_struct),HX_("struct",55,3a,39,11)},
	{hx::fsInt,(int)offsetof(Geometry_obj,structLength),HX_("structLength",1b,31,1d,c1)},
	{hx::fsString,(int)offsetof(Geometry_obj,structStr),HX_("structStr",5c,89,35,47)},
	{hx::fsObject /*::kha::graphics4::Usage*/ ,(int)offsetof(Geometry_obj,usage),HX_("usage",21,5d,2f,aa)},
	{hx::fsObject /*::kha::graphics4::VertexBuffer*/ ,(int)offsetof(Geometry_obj,instancedVB),HX_("instancedVB",1b,38,25,29)},
	{hx::fsBool,(int)offsetof(Geometry_obj,instanced),HX_("instanced",2f,83,1a,4b)},
	{hx::fsInt,(int)offsetof(Geometry_obj,instanceCount),HX_("instanceCount",fa,f8,6b,b7)},
	{hx::fsObject /*::kha::arrays::Float32ArrayPrivate*/ ,(int)offsetof(Geometry_obj,positions),HX_("positions",aa,f3,51,d0)},
	{hx::fsObject /*::kha::arrays::Float32ArrayPrivate*/ ,(int)offsetof(Geometry_obj,normals),HX_("normals",6c,70,da,2b)},
	{hx::fsObject /*::kha::arrays::Float32ArrayPrivate*/ ,(int)offsetof(Geometry_obj,uvs),HX_("uvs",f2,2e,59,00)},
	{hx::fsObject /*::kha::arrays::Float32ArrayPrivate*/ ,(int)offsetof(Geometry_obj,uvs1),HX_("uvs1",ff,e4,af,4d)},
	{hx::fsObject /*::kha::arrays::Float32ArrayPrivate*/ ,(int)offsetof(Geometry_obj,cols),HX_("cols",33,b8,c4,41)},
	{hx::fsObject /*::kha::arrays::Float32ArrayPrivate*/ ,(int)offsetof(Geometry_obj,tangents),HX_("tangents",0e,90,1b,39)},
	{hx::fsObject /*::kha::arrays::Float32ArrayPrivate*/ ,(int)offsetof(Geometry_obj,bones),HX_("bones",af,58,f7,b6)},
	{hx::fsObject /*::kha::arrays::Float32ArrayPrivate*/ ,(int)offsetof(Geometry_obj,weights),HX_("weights",fb,d7,fc,6f)},
	{hx::fsObject /*::kha::arrays::Float32ArrayPrivate*/ ,(int)offsetof(Geometry_obj,instancedData),HX_("instancedData",f9,c8,29,9b)},
	{hx::fsObject /*Dynamic*/ ,(int)offsetof(Geometry_obj,instancedType),HX_("instancedType",89,65,cf,a5)},
	{hx::fsObject /*::iron::math::Vec4*/ ,(int)offsetof(Geometry_obj,aabb),HX_("aabb",a0,a2,67,40)},
	{hx::fsObject /*::kha::arrays::Uint32ArrayPrivate*/ ,(int)offsetof(Geometry_obj,skinBoneCounts),HX_("skinBoneCounts",05,ac,f8,f8)},
	{hx::fsObject /*::kha::arrays::Uint32ArrayPrivate*/ ,(int)offsetof(Geometry_obj,skinBoneIndices),HX_("skinBoneIndices",c6,64,98,a6)},
	{hx::fsObject /*::kha::arrays::Float32ArrayPrivate*/ ,(int)offsetof(Geometry_obj,skinBoneWeights),HX_("skinBoneWeights",9a,f5,40,33)},
	{hx::fsObject /*Array< ::Dynamic >*/ ,(int)offsetof(Geometry_obj,skeletonTransformsI),HX_("skeletonTransformsI",15,d4,ac,3a)},
	{hx::fsObject /*Array< ::String >*/ ,(int)offsetof(Geometry_obj,skeletonBoneRefs),HX_("skeletonBoneRefs",11,b4,c3,74)},
	{hx::fsObject /*::kha::arrays::Float32ArrayPrivate*/ ,(int)offsetof(Geometry_obj,skeletonBoneLens),HX_("skeletonBoneLens",4f,73,cc,70)},
	{hx::fsObject /*::haxe::ds::StringMap*/ ,(int)offsetof(Geometry_obj,actions),HX_("actions",fd,03,2e,67)},
	{hx::fsObject /*::haxe::ds::StringMap*/ ,(int)offsetof(Geometry_obj,mats),HX_("mats",d3,41,56,48)},
	{ hx::fsUnknown, 0, null()}
};
static hx::StaticInfo *Geometry_obj_sStaticStorageInfo = 0;
#endif

static ::String Geometry_obj_sMemberFields[] = {
	HX_("vertexBuffer",84,af,a9,70),
	HX_("vertexBufferMap",78,9d,c8,a2),
	HX_("indexBuffers",81,96,f2,fb),
	HX_("start",62,74,0b,84),
	HX_("count",cf,44,63,4a),
	HX_("name",4b,72,ff,48),
	HX_("ready",63,a0,ba,e6),
	HX_("vertices",f9,bf,15,6a),
	HX_("indices",27,47,54,e3),
	HX_("numTris",4e,42,84,a0),
	HX_("materialIndices",40,05,8c,bf),
	HX_("struct",55,3a,39,11),
	HX_("structLength",1b,31,1d,c1),
	HX_("structStr",5c,89,35,47),
	HX_("usage",21,5d,2f,aa),
	HX_("instancedVB",1b,38,25,29),
	HX_("instanced",2f,83,1a,4b),
	HX_("instanceCount",fa,f8,6b,b7),
	HX_("positions",aa,f3,51,d0),
	HX_("normals",6c,70,da,2b),
	HX_("uvs",f2,2e,59,00),
	HX_("uvs1",ff,e4,af,4d),
	HX_("cols",33,b8,c4,41),
	HX_("tangents",0e,90,1b,39),
	HX_("bones",af,58,f7,b6),
	HX_("weights",fb,d7,fc,6f),
	HX_("instancedData",f9,c8,29,9b),
	HX_("instancedType",89,65,cf,a5),
	HX_("aabb",a0,a2,67,40),
	HX_("skinBoneCounts",05,ac,f8,f8),
	HX_("skinBoneIndices",c6,64,98,a6),
	HX_("skinBoneWeights",9a,f5,40,33),
	HX_("skeletonTransformsI",15,d4,ac,3a),
	HX_("skeletonBoneRefs",11,b4,c3,74),
	HX_("skeletonBoneLens",4f,73,cc,70),
	HX_("actions",fd,03,2e,67),
	HX_("mats",d3,41,56,48),
	HX_("delete",2b,c0,d8,6a),
	HX_("applyScale",3c,4a,20,24),
	HX_("setupInstanced",f2,7c,b4,b6),
	HX_("copyVertices",ce,74,ee,65),
	HX_("getVerticesLength",f5,38,df,e3),
	HX_("hasAttrib",44,9a,05,21),
	HX_("get",96,80,4e,00),
	HX_("build",2e,db,ea,ba),
	HX_("getVerticesCount",a0,17,44,ea),
	HX_("addArmature",ba,db,d2,1d),
	HX_("addAction",b7,70,6a,ce),
	HX_("initSkeletonTransforms",e4,0c,81,a4),
	HX_("calculateAABB",06,ab,e0,9c),
	::String(null()) };

hx::Class Geometry_obj::__mClass;

static ::String Geometry_obj_sStaticFields[] = {
	HX_("getVertexStructure",39,6c,63,eb),
	HX_("buildVertices",47,35,e6,64),
	::String(null())
};

void Geometry_obj::__register()
{
	Geometry_obj _hx_dummy;
	Geometry_obj::_hx_vtable = *(void **)&_hx_dummy;
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_("iron.data.Geometry",f0,23,2b,36);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &Geometry_obj::__GetStatic;
	__mClass->mSetStaticField = &hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = hx::Class_obj::dupFunctions(Geometry_obj_sStaticFields);
	__mClass->mMembers = hx::Class_obj::dupFunctions(Geometry_obj_sMemberFields);
	__mClass->mCanCast = hx::TCanCast< Geometry_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Geometry_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Geometry_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace iron
} // end namespace data
