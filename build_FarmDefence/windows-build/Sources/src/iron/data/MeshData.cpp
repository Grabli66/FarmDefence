// Generated by Haxe 4.0.0-preview.4+6e012c1
#include <hxcpp.h>

#ifndef INCLUDED_c5728fd05c542abe
#define INCLUDED_c5728fd05c542abe
#include "cpp_float32array.h"
#endif
#ifndef INCLUDED_7d028c26efabce49
#define INCLUDED_7d028c26efabce49
#include "cpp_uint32array.h"
#endif
#ifndef INCLUDED_Std
#include <hxinc/Std.h>
#endif
#ifndef INCLUDED_haxe_Log
#include <hxinc/haxe/Log.h>
#endif
#ifndef INCLUDED_iron_data_Data
#include <hxinc/iron/data/Data.h>
#endif
#ifndef INCLUDED_iron_data_Geometry
#include <hxinc/iron/data/Geometry.h>
#endif
#ifndef INCLUDED_iron_data_MeshData
#include <hxinc/iron/data/MeshData.h>
#endif
#ifndef INCLUDED_iron_data_TIndexArray
#include <hxinc/iron/data/TIndexArray.h>
#endif
#ifndef INCLUDED_iron_data_TMeshData
#include <hxinc/iron/data/TMeshData.h>
#endif
#ifndef INCLUDED_iron_data_TSceneFormat
#include <hxinc/iron/data/TSceneFormat.h>
#endif
#ifndef INCLUDED_iron_data_TSkin
#include <hxinc/iron/data/TSkin.h>
#endif
#ifndef INCLUDED_iron_data_TVertexArray
#include <hxinc/iron/data/TVertexArray.h>
#endif
#ifndef INCLUDED_kha_arrays_Float32ArrayPrivate
#include <hxinc/kha/arrays/Float32ArrayPrivate.h>
#endif
#ifndef INCLUDED_kha_arrays_Uint32ArrayPrivate
#include <hxinc/kha/arrays/Uint32ArrayPrivate.h>
#endif
#ifndef INCLUDED_kha_graphics4_Usage
#include <hxinc/kha/graphics4/Usage.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_45dd5ffeb7a89160_10_new,"iron.data.MeshData","new",0x6f4f2767,"iron.data.MeshData.new","iron/data/MeshData.hx",10,0x918a4189)
HX_LOCAL_STACK_FRAME(_hx_pos_45dd5ffeb7a89160_97_delete,"iron.data.MeshData","delete",0xd0ee4784,"iron.data.MeshData.delete","iron/data/MeshData.hx",97,0x918a4189)
HX_LOCAL_STACK_FRAME(_hx_pos_45dd5ffeb7a89160_139_getVertexArrayValues,"iron.data.MeshData","getVertexArrayValues",0x9ddb94fa,"iron.data.MeshData.getVertexArrayValues","iron/data/MeshData.hx",139,0x918a4189)
HX_LOCAL_STACK_FRAME(_hx_pos_45dd5ffeb7a89160_108_parse,"iron.data.MeshData","parse",0x6319f6fa,"iron.data.MeshData.parse","iron/data/MeshData.hx",108,0x918a4189)
HX_LOCAL_STACK_FRAME(_hx_pos_45dd5ffeb7a89160_101_parse,"iron.data.MeshData","parse",0x6319f6fa,"iron.data.MeshData.parse","iron/data/MeshData.hx",101,0x918a4189)
namespace iron{
namespace data{

void MeshData_obj::__construct( ::iron::data::TMeshData raw, ::Dynamic done){
            	HX_GC_STACKFRAME(&_hx_pos_45dd5ffeb7a89160_10_new)
HXLINE(  18)		this->refcount = 0;
HXLINE(  17)		this->count = -1;
HXLINE(  16)		this->start = 0;
HXLINE(  28)		super::__construct();
HXLINE(  30)		this->raw = raw;
HXLINE(  31)		this->name = raw->name;
HXLINE(  34)		::Array< ::Dynamic> indices = ::Array_obj< ::Dynamic>::__new(0);
HXLINE(  35)		::Array< int > materialIndices = ::Array_obj< int >::__new(0);
HXLINE(  36)		{
HXLINE(  36)			int _g = 0;
HXDLIN(  36)			::Array< ::Dynamic> _g1 = raw->index_arrays;
HXDLIN(  36)			while((_g < _g1->length)){
HXLINE(  36)				 ::iron::data::TIndexArray ind = _g1->__get(_g).StaticCast<  ::iron::data::TIndexArray >();
HXDLIN(  36)				_g = (_g + 1);
HXLINE(  37)				indices->push(ind->values);
HXLINE(  38)				materialIndices->push(ind->material);
            			}
            		}
HXLINE(  42)		 ::kha::arrays::Float32ArrayPrivate pa = this->getVertexArrayValues(HX_("pos",94,5d,55,00));
HXLINE(  43)		 ::kha::arrays::Float32ArrayPrivate na = this->getVertexArrayValues(HX_("nor",11,d9,53,00));
HXLINE(  44)		 ::kha::arrays::Float32ArrayPrivate uva = this->getVertexArrayValues(HX_("tex",e7,5d,58,00));
HXLINE(  45)		 ::kha::arrays::Float32ArrayPrivate uva1 = this->getVertexArrayValues(HX_("tex1",6a,cc,f9,4c));
HXLINE(  46)		 ::kha::arrays::Float32ArrayPrivate ca = this->getVertexArrayValues(HX_("col",40,80,4b,00));
HXLINE(  47)		 ::kha::arrays::Float32ArrayPrivate tanga = this->getVertexArrayValues(HX_("tang",e6,ba,f6,4c));
HXLINE(  50)		this->isSkinned = hx::IsNotNull( raw->skin );
HXLINE(  53)		 ::kha::graphics4::Usage parsedUsage = ::kha::graphics4::Usage_obj::StaticUsage_dyn();
HXLINE(  54)		bool _hx_tmp;
HXDLIN(  54)		if (hx::IsNotNull( raw->dynamic_usage )) {
HXLINE(  54)			_hx_tmp = hx::IsEq( raw->dynamic_usage,true );
            		}
            		else {
HXLINE(  54)			_hx_tmp = false;
            		}
HXDLIN(  54)		if (_hx_tmp) {
HXLINE(  54)			parsedUsage = ::kha::graphics4::Usage_obj::DynamicUsage_dyn();
            		}
HXLINE(  58)		 ::kha::graphics4::Usage usage = parsedUsage;
HXLINE(  61)		 ::kha::arrays::Float32ArrayPrivate bonea = null();
HXLINE(  62)		 ::kha::arrays::Float32ArrayPrivate weighta = null();
HXLINE(  64)		if (this->isSkinned) {
HXLINE(  65)			int l = (::Std_obj::_hx_int((( (Float)(pa->self.length()) ) / ( (Float)(3) ))) * 4);
HXLINE(  66)			 ::kha::arrays::Float32ArrayPrivate this1 =  ::kha::arrays::Float32ArrayPrivate_obj::__alloc( HX_CTX ,l);
HXDLIN(  66)			bonea = this1;
HXLINE(  67)			 ::kha::arrays::Float32ArrayPrivate this2 =  ::kha::arrays::Float32ArrayPrivate_obj::__alloc( HX_CTX ,l);
HXDLIN(  67)			weighta = this2;
HXLINE(  69)			int index = 0;
HXLINE(  70)			int ai = 0;
HXLINE(  71)			{
HXLINE(  71)				int _g11 = 0;
HXDLIN(  71)				int _g2 = ::Std_obj::_hx_int((( (Float)(pa->self.length()) ) / ( (Float)(3) )));
HXDLIN(  71)				while((_g11 < _g2)){
HXLINE(  71)					_g11 = (_g11 + 1);
HXDLIN(  71)					int i = (_g11 - 1);
HXLINE(  72)					int boneCount = raw->skin->bone_count_array->self.get(i);
HXLINE(  73)					{
HXLINE(  73)						int _g3 = index;
HXDLIN(  73)						int _g21 = (index + boneCount);
HXDLIN(  73)						while((_g3 < _g21)){
HXLINE(  73)							_g3 = (_g3 + 1);
HXDLIN(  73)							int j = (_g3 - 1);
HXLINE(  74)							{
HXLINE(  74)								float value = ( (float)(raw->skin->bone_index_array->self.get(j)) );
HXDLIN(  74)								bonea->self.set(ai,value);
            							}
HXLINE(  75)							{
HXLINE(  75)								float value1 = raw->skin->bone_weight_array->self.get(j);
HXDLIN(  75)								weighta->self.set(ai,value1);
            							}
HXLINE(  76)							ai = (ai + 1);
            						}
            					}
HXLINE(  79)					{
HXLINE(  79)						int _g22 = boneCount;
HXDLIN(  79)						while((_g22 < 4)){
HXLINE(  79)							_g22 = (_g22 + 1);
HXDLIN(  79)							int j1 = (_g22 - 1);
HXLINE(  80)							bonea->self.set(ai,( (float)(((Float)0.0)) ));
HXLINE(  81)							weighta->self.set(ai,( (float)(((Float)0.0)) ));
HXLINE(  82)							ai = (ai + 1);
            						}
            					}
HXLINE(  84)					index = (index + boneCount);
            				}
            			}
            		}
HXLINE(  90)		this->geom =  ::iron::data::Geometry_obj::__alloc( HX_CTX ,indices,materialIndices,pa,na,uva,uva1,ca,tanga,bonea,weighta,usage,raw->instanced_data,raw->instanced_type);
HXLINE(  91)		this->geom->name = this->name;
HXLINE(  93)		done(hx::ObjectPtr<OBJ_>(this));
            	}

Dynamic MeshData_obj::__CreateEmpty() { return new MeshData_obj; }

void *MeshData_obj::_hx_vtable = 0;

Dynamic MeshData_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< MeshData_obj > _hx_result = new MeshData_obj();
	_hx_result->__construct(inArgs[0],inArgs[1]);
	return _hx_result;
}

bool MeshData_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x25e6a720) {
		return inClassId==(int)0x00000001 || inClassId==(int)0x25e6a720;
	} else {
		return inClassId==(int)0x796fc049;
	}
}

void MeshData_obj::_hx_delete(){
            	HX_STACKFRAME(&_hx_pos_45dd5ffeb7a89160_97_delete)
HXDLIN(  97)		this->geom->_hx_delete();
            	}


HX_DEFINE_DYNAMIC_FUNC0(MeshData_obj,_hx_delete,(void))

 ::kha::arrays::Float32ArrayPrivate MeshData_obj::getVertexArrayValues(::String attrib){
            	HX_STACKFRAME(&_hx_pos_45dd5ffeb7a89160_139_getVertexArrayValues)
HXLINE( 140)		{
HXLINE( 140)			int _g = 0;
HXDLIN( 140)			::Array< ::Dynamic> _g1 = this->raw->vertex_arrays;
HXDLIN( 140)			while((_g < _g1->length)){
HXLINE( 140)				 ::iron::data::TVertexArray va = _g1->__get(_g).StaticCast<  ::iron::data::TVertexArray >();
HXDLIN( 140)				_g = (_g + 1);
HXDLIN( 140)				if ((va->attrib == attrib)) {
HXLINE( 140)					return va->values;
            				}
            			}
            		}
HXLINE( 141)		return null();
            	}


HX_DEFINE_DYNAMIC_FUNC1(MeshData_obj,getVertexArrayValues,return )

void MeshData_obj::parse(::String name,::String id, ::Dynamic done){
            		HX_BEGIN_LOCAL_FUNC_S2(hx::LocalFunc,_hx_Closure_1,::String,id, ::Dynamic,done) HXARGC(1)
            		void _hx_run( ::iron::data::TSceneFormat format){
            			HX_BEGIN_LOCAL_FUNC_S3(hx::LocalFunc,_hx_Closure_0, ::iron::data::TMeshData,raw, ::Dynamic,done, ::iron::data::TSceneFormat,format) HXARGC(1)
            			void _hx_run( ::iron::data::MeshData dat){
            				HX_STACKFRAME(&_hx_pos_45dd5ffeb7a89160_108_parse)
HXLINE( 109)				dat->format = format;
HXLINE( 111)				if (hx::IsNotNull( raw->skin )) {
HXLINE( 115)					dat->geom->skinBoneCounts = raw->skin->bone_count_array;
HXLINE( 116)					dat->geom->skinBoneIndices = raw->skin->bone_index_array;
HXLINE( 117)					dat->geom->skinBoneWeights = raw->skin->bone_weight_array;
HXLINE( 118)					dat->geom->skeletonBoneRefs = raw->skin->bone_ref_array;
HXLINE( 119)					dat->geom->skeletonBoneLens = raw->skin->bone_len_array;
HXLINE( 120)					dat->geom->initSkeletonTransforms(raw->skin->transformsI);
            				}
HXLINE( 134)				done(dat);
            			}
            			HX_END_LOCAL_FUNC1((void))

            			HX_GC_STACKFRAME(&_hx_pos_45dd5ffeb7a89160_101_parse)
HXLINE( 102)			 ::iron::data::TMeshData raw = ::iron::data::Data_obj::getMeshRawByName(format->mesh_datas,id);
HXLINE( 103)			if (hx::IsNull( raw )) {
HXLINE( 104)				 ::Dynamic _hx_tmp = ::haxe::Log_obj::trace;
HXDLIN( 104)				_hx_tmp(((HX_("Mesh data \"",5f,be,6b,f4) + id) + HX_("\" not found!",4a,86,fb,0a)),hx::SourceInfo(HX_("Sources/iron/data/MeshData.hx",12,32,e8,d3),104,HX_("iron.data.MeshData",f5,e7,e7,2f),HX_("parse",33,90,55,bd)));
HXLINE( 105)				done(null());
            			}
HXLINE( 108)			 ::iron::data::MeshData_obj::__alloc( HX_CTX ,raw, ::Dynamic(new _hx_Closure_0(raw,done,format)));
            		}
            		HX_END_LOCAL_FUNC1((void))

            	HX_STACKFRAME(&_hx_pos_45dd5ffeb7a89160_101_parse)
HXDLIN( 101)		::iron::data::Data_obj::getSceneRaw(name, ::Dynamic(new _hx_Closure_1(id,done)));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(MeshData_obj,parse,(void))


hx::ObjectPtr< MeshData_obj > MeshData_obj::__new( ::iron::data::TMeshData raw, ::Dynamic done) {
	hx::ObjectPtr< MeshData_obj > __this = new MeshData_obj();
	__this->__construct(raw,done);
	return __this;
}

hx::ObjectPtr< MeshData_obj > MeshData_obj::__alloc(hx::Ctx *_hx_ctx, ::iron::data::TMeshData raw, ::Dynamic done) {
	MeshData_obj *__this = (MeshData_obj*)(hx::Ctx::alloc(_hx_ctx, sizeof(MeshData_obj), true, "iron.data.MeshData"));
	*(void **)__this = MeshData_obj::_hx_vtable;
	__this->__construct(raw,done);
	return __this;
}

MeshData_obj::MeshData_obj()
{
}

void MeshData_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(MeshData);
	HX_MARK_MEMBER_NAME(name,"name");
	HX_MARK_MEMBER_NAME(raw,"raw");
	HX_MARK_MEMBER_NAME(format,"format");
	HX_MARK_MEMBER_NAME(geom,"geom");
	HX_MARK_MEMBER_NAME(start,"start");
	HX_MARK_MEMBER_NAME(count,"count");
	HX_MARK_MEMBER_NAME(refcount,"refcount");
	HX_MARK_MEMBER_NAME(handle,"handle");
	HX_MARK_MEMBER_NAME(isSkinned,"isSkinned");
	HX_MARK_END_CLASS();
}

void MeshData_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(name,"name");
	HX_VISIT_MEMBER_NAME(raw,"raw");
	HX_VISIT_MEMBER_NAME(format,"format");
	HX_VISIT_MEMBER_NAME(geom,"geom");
	HX_VISIT_MEMBER_NAME(start,"start");
	HX_VISIT_MEMBER_NAME(count,"count");
	HX_VISIT_MEMBER_NAME(refcount,"refcount");
	HX_VISIT_MEMBER_NAME(handle,"handle");
	HX_VISIT_MEMBER_NAME(isSkinned,"isSkinned");
}

hx::Val MeshData_obj::__Field(const ::String &inName,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 3:
		if (HX_FIELD_EQ(inName,"raw") ) { return hx::Val( raw ); }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"name") ) { return hx::Val( name ); }
		if (HX_FIELD_EQ(inName,"geom") ) { return hx::Val( geom ); }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"start") ) { return hx::Val( start ); }
		if (HX_FIELD_EQ(inName,"count") ) { return hx::Val( count ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"format") ) { return hx::Val( format ); }
		if (HX_FIELD_EQ(inName,"handle") ) { return hx::Val( handle ); }
		if (HX_FIELD_EQ(inName,"delete") ) { return hx::Val( _hx_delete_dyn() ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"refcount") ) { return hx::Val( refcount ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"isSkinned") ) { return hx::Val( isSkinned ); }
		break;
	case 20:
		if (HX_FIELD_EQ(inName,"getVertexArrayValues") ) { return hx::Val( getVertexArrayValues_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

bool MeshData_obj::__GetStatic(const ::String &inName, Dynamic &outValue, hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 5:
		if (HX_FIELD_EQ(inName,"parse") ) { outValue = parse_dyn(); return true; }
	}
	return false;
}

hx::Val MeshData_obj::__SetField(const ::String &inName,const hx::Val &inValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 3:
		if (HX_FIELD_EQ(inName,"raw") ) { raw=inValue.Cast<  ::iron::data::TMeshData >(); return inValue; }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"name") ) { name=inValue.Cast< ::String >(); return inValue; }
		if (HX_FIELD_EQ(inName,"geom") ) { geom=inValue.Cast<  ::iron::data::Geometry >(); return inValue; }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"start") ) { start=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"count") ) { count=inValue.Cast< int >(); return inValue; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"format") ) { format=inValue.Cast<  ::iron::data::TSceneFormat >(); return inValue; }
		if (HX_FIELD_EQ(inName,"handle") ) { handle=inValue.Cast< ::String >(); return inValue; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"refcount") ) { refcount=inValue.Cast< int >(); return inValue; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"isSkinned") ) { isSkinned=inValue.Cast< bool >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void MeshData_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("name",4b,72,ff,48));
	outFields->push(HX_("raw",e8,d5,56,00));
	outFields->push(HX_("format",37,8f,8e,fd));
	outFields->push(HX_("geom",bc,fe,61,44));
	outFields->push(HX_("start",62,74,0b,84));
	outFields->push(HX_("count",cf,44,63,4a));
	outFields->push(HX_("refcount",9c,be,38,f3));
	outFields->push(HX_("handle",a8,83,fd,b7));
	outFields->push(HX_("isSkinned",26,a3,6e,38));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static hx::StorageInfo MeshData_obj_sMemberStorageInfo[] = {
	{hx::fsString,(int)offsetof(MeshData_obj,name),HX_("name",4b,72,ff,48)},
	{hx::fsObject /*::iron::data::TMeshData*/ ,(int)offsetof(MeshData_obj,raw),HX_("raw",e8,d5,56,00)},
	{hx::fsObject /*::iron::data::TSceneFormat*/ ,(int)offsetof(MeshData_obj,format),HX_("format",37,8f,8e,fd)},
	{hx::fsObject /*::iron::data::Geometry*/ ,(int)offsetof(MeshData_obj,geom),HX_("geom",bc,fe,61,44)},
	{hx::fsInt,(int)offsetof(MeshData_obj,start),HX_("start",62,74,0b,84)},
	{hx::fsInt,(int)offsetof(MeshData_obj,count),HX_("count",cf,44,63,4a)},
	{hx::fsInt,(int)offsetof(MeshData_obj,refcount),HX_("refcount",9c,be,38,f3)},
	{hx::fsString,(int)offsetof(MeshData_obj,handle),HX_("handle",a8,83,fd,b7)},
	{hx::fsBool,(int)offsetof(MeshData_obj,isSkinned),HX_("isSkinned",26,a3,6e,38)},
	{ hx::fsUnknown, 0, null()}
};
static hx::StaticInfo *MeshData_obj_sStaticStorageInfo = 0;
#endif

static ::String MeshData_obj_sMemberFields[] = {
	HX_("name",4b,72,ff,48),
	HX_("raw",e8,d5,56,00),
	HX_("format",37,8f,8e,fd),
	HX_("geom",bc,fe,61,44),
	HX_("start",62,74,0b,84),
	HX_("count",cf,44,63,4a),
	HX_("refcount",9c,be,38,f3),
	HX_("handle",a8,83,fd,b7),
	HX_("isSkinned",26,a3,6e,38),
	HX_("delete",2b,c0,d8,6a),
	HX_("getVertexArrayValues",e1,43,4d,20),
	::String(null()) };

hx::Class MeshData_obj::__mClass;

static ::String MeshData_obj_sStaticFields[] = {
	HX_("parse",33,90,55,bd),
	::String(null())
};

void MeshData_obj::__register()
{
	MeshData_obj _hx_dummy;
	MeshData_obj::_hx_vtable = *(void **)&_hx_dummy;
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_("iron.data.MeshData",f5,e7,e7,2f);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &MeshData_obj::__GetStatic;
	__mClass->mSetStaticField = &hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = hx::Class_obj::dupFunctions(MeshData_obj_sStaticFields);
	__mClass->mMembers = hx::Class_obj::dupFunctions(MeshData_obj_sMemberFields);
	__mClass->mCanCast = hx::TCanCast< MeshData_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = MeshData_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = MeshData_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace iron
} // end namespace data
