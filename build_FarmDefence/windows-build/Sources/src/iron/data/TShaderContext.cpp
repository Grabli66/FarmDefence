// Generated by Haxe 4.0.0-preview.4+6e012c1
#include <hxcpp.h>

#ifndef INCLUDED_iron_data_TShaderConstant
#include <hxinc/iron/data/TShaderConstant.h>
#endif
#ifndef INCLUDED_iron_data_TShaderContext
#include <hxinc/iron/data/TShaderContext.h>
#endif
#ifndef INCLUDED_iron_data_TTextureUnit
#include <hxinc/iron/data/TTextureUnit.h>
#endif
#ifndef INCLUDED_iron_data_TVertexData
#include <hxinc/iron/data/TVertexData.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_0a114a9510ef5b82_200_new,"iron.data.TShaderContext","new",0x71eec2e6,"iron.data.TShaderContext.new","iron/data/SceneFormat.hx",200,0x98b03519)
namespace iron{
namespace data{

void TShaderContext_obj::__construct(::String name,bool depth_write,::String compare_mode,::String cull_mode,::Array< ::Dynamic> vertex_structure,::String vertex_shader,::String fragment_shader,::String geometry_shader,::String tesscontrol_shader,::String tesseval_shader,::Array< ::Dynamic> constants,::Array< ::Dynamic> texture_units,::String blend_source,::String blend_destination,::String blend_operation,::String alpha_blend_source,::String alpha_blend_destination,::String alpha_blend_operation,::String stencil_mode,::String stencil_pass,::String stencil_fail, ::Dynamic stencil_reference_value, ::Dynamic stencil_read_mask, ::Dynamic stencil_write_mask, ::Dynamic color_write_red, ::Dynamic color_write_green, ::Dynamic color_write_blue, ::Dynamic color_write_alpha, ::Dynamic conservative_raster, ::Dynamic shader_from_source){
            	HX_STACKFRAME(&_hx_pos_0a114a9510ef5b82_200_new)
HXDLIN( 200)		this->name = name;
HXDLIN( 200)		this->depth_write = depth_write;
HXDLIN( 200)		this->compare_mode = compare_mode;
HXDLIN( 200)		this->cull_mode = cull_mode;
HXDLIN( 200)		this->vertex_structure = vertex_structure;
HXDLIN( 200)		this->vertex_shader = vertex_shader;
HXDLIN( 200)		this->fragment_shader = fragment_shader;
HXDLIN( 200)		this->geometry_shader = geometry_shader;
HXDLIN( 200)		this->tesscontrol_shader = tesscontrol_shader;
HXDLIN( 200)		this->tesseval_shader = tesseval_shader;
HXDLIN( 200)		this->constants = constants;
HXDLIN( 200)		this->texture_units = texture_units;
HXDLIN( 200)		this->blend_source = blend_source;
HXDLIN( 200)		this->blend_destination = blend_destination;
HXDLIN( 200)		this->blend_operation = blend_operation;
HXDLIN( 200)		this->alpha_blend_source = alpha_blend_source;
HXDLIN( 200)		this->alpha_blend_destination = alpha_blend_destination;
HXDLIN( 200)		this->alpha_blend_operation = alpha_blend_operation;
HXDLIN( 200)		this->stencil_mode = stencil_mode;
HXDLIN( 200)		this->stencil_pass = stencil_pass;
HXDLIN( 200)		this->stencil_fail = stencil_fail;
HXDLIN( 200)		this->stencil_reference_value = stencil_reference_value;
HXDLIN( 200)		this->stencil_read_mask = stencil_read_mask;
HXDLIN( 200)		this->stencil_write_mask = stencil_write_mask;
HXDLIN( 200)		this->color_write_red = color_write_red;
HXDLIN( 200)		this->color_write_green = color_write_green;
HXDLIN( 200)		this->color_write_blue = color_write_blue;
HXDLIN( 200)		this->color_write_alpha = color_write_alpha;
HXDLIN( 200)		this->conservative_raster = conservative_raster;
HXDLIN( 200)		this->shader_from_source = shader_from_source;
            	}

Dynamic TShaderContext_obj::__CreateEmpty() { return new TShaderContext_obj; }

void *TShaderContext_obj::_hx_vtable = 0;

Dynamic TShaderContext_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< TShaderContext_obj > _hx_result = new TShaderContext_obj();
	_hx_result->__construct(inArgs[0],inArgs[1],inArgs[2],inArgs[3],inArgs[4],inArgs[5],inArgs[6],inArgs[7],inArgs[8],inArgs[9],inArgs[10],inArgs[11],inArgs[12],inArgs[13],inArgs[14],inArgs[15],inArgs[16],inArgs[17],inArgs[18],inArgs[19],inArgs[20],inArgs[21],inArgs[22],inArgs[23],inArgs[24],inArgs[25],inArgs[26],inArgs[27],inArgs[28],inArgs[29]);
	return _hx_result;
}

bool TShaderContext_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x1b0ec210;
}


hx::ObjectPtr< TShaderContext_obj > TShaderContext_obj::__new(::String name,bool depth_write,::String compare_mode,::String cull_mode,::Array< ::Dynamic> vertex_structure,::String vertex_shader,::String fragment_shader,::String geometry_shader,::String tesscontrol_shader,::String tesseval_shader,::Array< ::Dynamic> constants,::Array< ::Dynamic> texture_units,::String blend_source,::String blend_destination,::String blend_operation,::String alpha_blend_source,::String alpha_blend_destination,::String alpha_blend_operation,::String stencil_mode,::String stencil_pass,::String stencil_fail, ::Dynamic stencil_reference_value, ::Dynamic stencil_read_mask, ::Dynamic stencil_write_mask, ::Dynamic color_write_red, ::Dynamic color_write_green, ::Dynamic color_write_blue, ::Dynamic color_write_alpha, ::Dynamic conservative_raster, ::Dynamic shader_from_source) {
	hx::ObjectPtr< TShaderContext_obj > __this = new TShaderContext_obj();
	__this->__construct(name,depth_write,compare_mode,cull_mode,vertex_structure,vertex_shader,fragment_shader,geometry_shader,tesscontrol_shader,tesseval_shader,constants,texture_units,blend_source,blend_destination,blend_operation,alpha_blend_source,alpha_blend_destination,alpha_blend_operation,stencil_mode,stencil_pass,stencil_fail,stencil_reference_value,stencil_read_mask,stencil_write_mask,color_write_red,color_write_green,color_write_blue,color_write_alpha,conservative_raster,shader_from_source);
	return __this;
}

hx::ObjectPtr< TShaderContext_obj > TShaderContext_obj::__alloc(hx::Ctx *_hx_ctx,::String name,bool depth_write,::String compare_mode,::String cull_mode,::Array< ::Dynamic> vertex_structure,::String vertex_shader,::String fragment_shader,::String geometry_shader,::String tesscontrol_shader,::String tesseval_shader,::Array< ::Dynamic> constants,::Array< ::Dynamic> texture_units,::String blend_source,::String blend_destination,::String blend_operation,::String alpha_blend_source,::String alpha_blend_destination,::String alpha_blend_operation,::String stencil_mode,::String stencil_pass,::String stencil_fail, ::Dynamic stencil_reference_value, ::Dynamic stencil_read_mask, ::Dynamic stencil_write_mask, ::Dynamic color_write_red, ::Dynamic color_write_green, ::Dynamic color_write_blue, ::Dynamic color_write_alpha, ::Dynamic conservative_raster, ::Dynamic shader_from_source) {
	TShaderContext_obj *__this = (TShaderContext_obj*)(hx::Ctx::alloc(_hx_ctx, sizeof(TShaderContext_obj), true, "iron.data.TShaderContext"));
	*(void **)__this = TShaderContext_obj::_hx_vtable;
	__this->__construct(name,depth_write,compare_mode,cull_mode,vertex_structure,vertex_shader,fragment_shader,geometry_shader,tesscontrol_shader,tesseval_shader,constants,texture_units,blend_source,blend_destination,blend_operation,alpha_blend_source,alpha_blend_destination,alpha_blend_operation,stencil_mode,stencil_pass,stencil_fail,stencil_reference_value,stencil_read_mask,stencil_write_mask,color_write_red,color_write_green,color_write_blue,color_write_alpha,conservative_raster,shader_from_source);
	return __this;
}

TShaderContext_obj::TShaderContext_obj()
{
}

void TShaderContext_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(TShaderContext);
	HX_MARK_MEMBER_NAME(name,"name");
	HX_MARK_MEMBER_NAME(depth_write,"depth_write");
	HX_MARK_MEMBER_NAME(compare_mode,"compare_mode");
	HX_MARK_MEMBER_NAME(cull_mode,"cull_mode");
	HX_MARK_MEMBER_NAME(vertex_structure,"vertex_structure");
	HX_MARK_MEMBER_NAME(vertex_shader,"vertex_shader");
	HX_MARK_MEMBER_NAME(fragment_shader,"fragment_shader");
	HX_MARK_MEMBER_NAME(geometry_shader,"geometry_shader");
	HX_MARK_MEMBER_NAME(tesscontrol_shader,"tesscontrol_shader");
	HX_MARK_MEMBER_NAME(tesseval_shader,"tesseval_shader");
	HX_MARK_MEMBER_NAME(constants,"constants");
	HX_MARK_MEMBER_NAME(texture_units,"texture_units");
	HX_MARK_MEMBER_NAME(blend_source,"blend_source");
	HX_MARK_MEMBER_NAME(blend_destination,"blend_destination");
	HX_MARK_MEMBER_NAME(blend_operation,"blend_operation");
	HX_MARK_MEMBER_NAME(alpha_blend_source,"alpha_blend_source");
	HX_MARK_MEMBER_NAME(alpha_blend_destination,"alpha_blend_destination");
	HX_MARK_MEMBER_NAME(alpha_blend_operation,"alpha_blend_operation");
	HX_MARK_MEMBER_NAME(stencil_mode,"stencil_mode");
	HX_MARK_MEMBER_NAME(stencil_pass,"stencil_pass");
	HX_MARK_MEMBER_NAME(stencil_fail,"stencil_fail");
	HX_MARK_MEMBER_NAME(stencil_reference_value,"stencil_reference_value");
	HX_MARK_MEMBER_NAME(stencil_read_mask,"stencil_read_mask");
	HX_MARK_MEMBER_NAME(stencil_write_mask,"stencil_write_mask");
	HX_MARK_MEMBER_NAME(color_write_red,"color_write_red");
	HX_MARK_MEMBER_NAME(color_write_green,"color_write_green");
	HX_MARK_MEMBER_NAME(color_write_blue,"color_write_blue");
	HX_MARK_MEMBER_NAME(color_write_alpha,"color_write_alpha");
	HX_MARK_MEMBER_NAME(conservative_raster,"conservative_raster");
	HX_MARK_MEMBER_NAME(shader_from_source,"shader_from_source");
	HX_MARK_END_CLASS();
}

void TShaderContext_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(name,"name");
	HX_VISIT_MEMBER_NAME(depth_write,"depth_write");
	HX_VISIT_MEMBER_NAME(compare_mode,"compare_mode");
	HX_VISIT_MEMBER_NAME(cull_mode,"cull_mode");
	HX_VISIT_MEMBER_NAME(vertex_structure,"vertex_structure");
	HX_VISIT_MEMBER_NAME(vertex_shader,"vertex_shader");
	HX_VISIT_MEMBER_NAME(fragment_shader,"fragment_shader");
	HX_VISIT_MEMBER_NAME(geometry_shader,"geometry_shader");
	HX_VISIT_MEMBER_NAME(tesscontrol_shader,"tesscontrol_shader");
	HX_VISIT_MEMBER_NAME(tesseval_shader,"tesseval_shader");
	HX_VISIT_MEMBER_NAME(constants,"constants");
	HX_VISIT_MEMBER_NAME(texture_units,"texture_units");
	HX_VISIT_MEMBER_NAME(blend_source,"blend_source");
	HX_VISIT_MEMBER_NAME(blend_destination,"blend_destination");
	HX_VISIT_MEMBER_NAME(blend_operation,"blend_operation");
	HX_VISIT_MEMBER_NAME(alpha_blend_source,"alpha_blend_source");
	HX_VISIT_MEMBER_NAME(alpha_blend_destination,"alpha_blend_destination");
	HX_VISIT_MEMBER_NAME(alpha_blend_operation,"alpha_blend_operation");
	HX_VISIT_MEMBER_NAME(stencil_mode,"stencil_mode");
	HX_VISIT_MEMBER_NAME(stencil_pass,"stencil_pass");
	HX_VISIT_MEMBER_NAME(stencil_fail,"stencil_fail");
	HX_VISIT_MEMBER_NAME(stencil_reference_value,"stencil_reference_value");
	HX_VISIT_MEMBER_NAME(stencil_read_mask,"stencil_read_mask");
	HX_VISIT_MEMBER_NAME(stencil_write_mask,"stencil_write_mask");
	HX_VISIT_MEMBER_NAME(color_write_red,"color_write_red");
	HX_VISIT_MEMBER_NAME(color_write_green,"color_write_green");
	HX_VISIT_MEMBER_NAME(color_write_blue,"color_write_blue");
	HX_VISIT_MEMBER_NAME(color_write_alpha,"color_write_alpha");
	HX_VISIT_MEMBER_NAME(conservative_raster,"conservative_raster");
	HX_VISIT_MEMBER_NAME(shader_from_source,"shader_from_source");
}

hx::Val TShaderContext_obj::__Field(const ::String &inName,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"name") ) { return hx::Val( name ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"cull_mode") ) { return hx::Val( cull_mode ); }
		if (HX_FIELD_EQ(inName,"constants") ) { return hx::Val( constants ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"depth_write") ) { return hx::Val( depth_write ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"compare_mode") ) { return hx::Val( compare_mode ); }
		if (HX_FIELD_EQ(inName,"blend_source") ) { return hx::Val( blend_source ); }
		if (HX_FIELD_EQ(inName,"stencil_mode") ) { return hx::Val( stencil_mode ); }
		if (HX_FIELD_EQ(inName,"stencil_pass") ) { return hx::Val( stencil_pass ); }
		if (HX_FIELD_EQ(inName,"stencil_fail") ) { return hx::Val( stencil_fail ); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"vertex_shader") ) { return hx::Val( vertex_shader ); }
		if (HX_FIELD_EQ(inName,"texture_units") ) { return hx::Val( texture_units ); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"fragment_shader") ) { return hx::Val( fragment_shader ); }
		if (HX_FIELD_EQ(inName,"geometry_shader") ) { return hx::Val( geometry_shader ); }
		if (HX_FIELD_EQ(inName,"tesseval_shader") ) { return hx::Val( tesseval_shader ); }
		if (HX_FIELD_EQ(inName,"blend_operation") ) { return hx::Val( blend_operation ); }
		if (HX_FIELD_EQ(inName,"color_write_red") ) { return hx::Val( color_write_red ); }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"vertex_structure") ) { return hx::Val( vertex_structure ); }
		if (HX_FIELD_EQ(inName,"color_write_blue") ) { return hx::Val( color_write_blue ); }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"blend_destination") ) { return hx::Val( blend_destination ); }
		if (HX_FIELD_EQ(inName,"stencil_read_mask") ) { return hx::Val( stencil_read_mask ); }
		if (HX_FIELD_EQ(inName,"color_write_green") ) { return hx::Val( color_write_green ); }
		if (HX_FIELD_EQ(inName,"color_write_alpha") ) { return hx::Val( color_write_alpha ); }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"tesscontrol_shader") ) { return hx::Val( tesscontrol_shader ); }
		if (HX_FIELD_EQ(inName,"alpha_blend_source") ) { return hx::Val( alpha_blend_source ); }
		if (HX_FIELD_EQ(inName,"stencil_write_mask") ) { return hx::Val( stencil_write_mask ); }
		if (HX_FIELD_EQ(inName,"shader_from_source") ) { return hx::Val( shader_from_source ); }
		break;
	case 19:
		if (HX_FIELD_EQ(inName,"conservative_raster") ) { return hx::Val( conservative_raster ); }
		break;
	case 21:
		if (HX_FIELD_EQ(inName,"alpha_blend_operation") ) { return hx::Val( alpha_blend_operation ); }
		break;
	case 23:
		if (HX_FIELD_EQ(inName,"alpha_blend_destination") ) { return hx::Val( alpha_blend_destination ); }
		if (HX_FIELD_EQ(inName,"stencil_reference_value") ) { return hx::Val( stencil_reference_value ); }
	}
	return super::__Field(inName,inCallProp);
}

hx::Val TShaderContext_obj::__SetField(const ::String &inName,const hx::Val &inValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"name") ) { name=inValue.Cast< ::String >(); return inValue; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"cull_mode") ) { cull_mode=inValue.Cast< ::String >(); return inValue; }
		if (HX_FIELD_EQ(inName,"constants") ) { constants=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"depth_write") ) { depth_write=inValue.Cast< bool >(); return inValue; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"compare_mode") ) { compare_mode=inValue.Cast< ::String >(); return inValue; }
		if (HX_FIELD_EQ(inName,"blend_source") ) { blend_source=inValue.Cast< ::String >(); return inValue; }
		if (HX_FIELD_EQ(inName,"stencil_mode") ) { stencil_mode=inValue.Cast< ::String >(); return inValue; }
		if (HX_FIELD_EQ(inName,"stencil_pass") ) { stencil_pass=inValue.Cast< ::String >(); return inValue; }
		if (HX_FIELD_EQ(inName,"stencil_fail") ) { stencil_fail=inValue.Cast< ::String >(); return inValue; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"vertex_shader") ) { vertex_shader=inValue.Cast< ::String >(); return inValue; }
		if (HX_FIELD_EQ(inName,"texture_units") ) { texture_units=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"fragment_shader") ) { fragment_shader=inValue.Cast< ::String >(); return inValue; }
		if (HX_FIELD_EQ(inName,"geometry_shader") ) { geometry_shader=inValue.Cast< ::String >(); return inValue; }
		if (HX_FIELD_EQ(inName,"tesseval_shader") ) { tesseval_shader=inValue.Cast< ::String >(); return inValue; }
		if (HX_FIELD_EQ(inName,"blend_operation") ) { blend_operation=inValue.Cast< ::String >(); return inValue; }
		if (HX_FIELD_EQ(inName,"color_write_red") ) { color_write_red=inValue.Cast<  ::Dynamic >(); return inValue; }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"vertex_structure") ) { vertex_structure=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		if (HX_FIELD_EQ(inName,"color_write_blue") ) { color_write_blue=inValue.Cast<  ::Dynamic >(); return inValue; }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"blend_destination") ) { blend_destination=inValue.Cast< ::String >(); return inValue; }
		if (HX_FIELD_EQ(inName,"stencil_read_mask") ) { stencil_read_mask=inValue.Cast<  ::Dynamic >(); return inValue; }
		if (HX_FIELD_EQ(inName,"color_write_green") ) { color_write_green=inValue.Cast<  ::Dynamic >(); return inValue; }
		if (HX_FIELD_EQ(inName,"color_write_alpha") ) { color_write_alpha=inValue.Cast<  ::Dynamic >(); return inValue; }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"tesscontrol_shader") ) { tesscontrol_shader=inValue.Cast< ::String >(); return inValue; }
		if (HX_FIELD_EQ(inName,"alpha_blend_source") ) { alpha_blend_source=inValue.Cast< ::String >(); return inValue; }
		if (HX_FIELD_EQ(inName,"stencil_write_mask") ) { stencil_write_mask=inValue.Cast<  ::Dynamic >(); return inValue; }
		if (HX_FIELD_EQ(inName,"shader_from_source") ) { shader_from_source=inValue.Cast<  ::Dynamic >(); return inValue; }
		break;
	case 19:
		if (HX_FIELD_EQ(inName,"conservative_raster") ) { conservative_raster=inValue.Cast<  ::Dynamic >(); return inValue; }
		break;
	case 21:
		if (HX_FIELD_EQ(inName,"alpha_blend_operation") ) { alpha_blend_operation=inValue.Cast< ::String >(); return inValue; }
		break;
	case 23:
		if (HX_FIELD_EQ(inName,"alpha_blend_destination") ) { alpha_blend_destination=inValue.Cast< ::String >(); return inValue; }
		if (HX_FIELD_EQ(inName,"stencil_reference_value") ) { stencil_reference_value=inValue.Cast<  ::Dynamic >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void TShaderContext_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("name",4b,72,ff,48));
	outFields->push(HX_("depth_write",63,c9,b5,19));
	outFields->push(HX_("compare_mode",7d,60,f4,04));
	outFields->push(HX_("cull_mode",50,c4,74,6c));
	outFields->push(HX_("vertex_structure",58,50,9b,df));
	outFields->push(HX_("vertex_shader",e0,e9,85,30));
	outFields->push(HX_("fragment_shader",f4,0a,a9,c5));
	outFields->push(HX_("geometry_shader",52,68,06,7a));
	outFields->push(HX_("tesscontrol_shader",18,8f,62,58));
	outFields->push(HX_("tesseval_shader",f7,37,49,43));
	outFields->push(HX_("constants",8f,76,6b,44));
	outFields->push(HX_("texture_units",cb,0f,52,01));
	outFields->push(HX_("blend_source",49,f6,96,02));
	outFields->push(HX_("blend_destination",60,d6,9d,4e));
	outFields->push(HX_("blend_operation",79,d7,69,41));
	outFields->push(HX_("alpha_blend_source",0a,1f,b7,8a));
	outFields->push(HX_("alpha_blend_destination",ff,51,cd,c3));
	outFields->push(HX_("alpha_blend_operation",58,dd,64,7d));
	outFields->push(HX_("stencil_mode",c6,ff,af,c5));
	outFields->push(HX_("stencil_pass",34,11,a1,c7));
	outFields->push(HX_("stencil_fail",41,e6,04,c1));
	outFields->push(HX_("stencil_reference_value",3a,f1,d8,44));
	outFields->push(HX_("stencil_read_mask",72,46,a7,66));
	outFields->push(HX_("stencil_write_mask",2f,00,c1,a4));
	outFields->push(HX_("color_write_red",95,8d,56,11));
	outFields->push(HX_("color_write_green",07,5c,75,b1));
	outFields->push(HX_("color_write_blue",d6,49,d7,0f));
	outFields->push(HX_("color_write_alpha",a2,f4,1e,39));
	outFields->push(HX_("conservative_raster",0f,38,63,6e));
	outFields->push(HX_("shader_from_source",f6,0e,37,d1));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static hx::StorageInfo TShaderContext_obj_sMemberStorageInfo[] = {
	{hx::fsString,(int)offsetof(TShaderContext_obj,name),HX_("name",4b,72,ff,48)},
	{hx::fsBool,(int)offsetof(TShaderContext_obj,depth_write),HX_("depth_write",63,c9,b5,19)},
	{hx::fsString,(int)offsetof(TShaderContext_obj,compare_mode),HX_("compare_mode",7d,60,f4,04)},
	{hx::fsString,(int)offsetof(TShaderContext_obj,cull_mode),HX_("cull_mode",50,c4,74,6c)},
	{hx::fsObject /*Array< ::Dynamic >*/ ,(int)offsetof(TShaderContext_obj,vertex_structure),HX_("vertex_structure",58,50,9b,df)},
	{hx::fsString,(int)offsetof(TShaderContext_obj,vertex_shader),HX_("vertex_shader",e0,e9,85,30)},
	{hx::fsString,(int)offsetof(TShaderContext_obj,fragment_shader),HX_("fragment_shader",f4,0a,a9,c5)},
	{hx::fsString,(int)offsetof(TShaderContext_obj,geometry_shader),HX_("geometry_shader",52,68,06,7a)},
	{hx::fsString,(int)offsetof(TShaderContext_obj,tesscontrol_shader),HX_("tesscontrol_shader",18,8f,62,58)},
	{hx::fsString,(int)offsetof(TShaderContext_obj,tesseval_shader),HX_("tesseval_shader",f7,37,49,43)},
	{hx::fsObject /*Array< ::Dynamic >*/ ,(int)offsetof(TShaderContext_obj,constants),HX_("constants",8f,76,6b,44)},
	{hx::fsObject /*Array< ::Dynamic >*/ ,(int)offsetof(TShaderContext_obj,texture_units),HX_("texture_units",cb,0f,52,01)},
	{hx::fsString,(int)offsetof(TShaderContext_obj,blend_source),HX_("blend_source",49,f6,96,02)},
	{hx::fsString,(int)offsetof(TShaderContext_obj,blend_destination),HX_("blend_destination",60,d6,9d,4e)},
	{hx::fsString,(int)offsetof(TShaderContext_obj,blend_operation),HX_("blend_operation",79,d7,69,41)},
	{hx::fsString,(int)offsetof(TShaderContext_obj,alpha_blend_source),HX_("alpha_blend_source",0a,1f,b7,8a)},
	{hx::fsString,(int)offsetof(TShaderContext_obj,alpha_blend_destination),HX_("alpha_blend_destination",ff,51,cd,c3)},
	{hx::fsString,(int)offsetof(TShaderContext_obj,alpha_blend_operation),HX_("alpha_blend_operation",58,dd,64,7d)},
	{hx::fsString,(int)offsetof(TShaderContext_obj,stencil_mode),HX_("stencil_mode",c6,ff,af,c5)},
	{hx::fsString,(int)offsetof(TShaderContext_obj,stencil_pass),HX_("stencil_pass",34,11,a1,c7)},
	{hx::fsString,(int)offsetof(TShaderContext_obj,stencil_fail),HX_("stencil_fail",41,e6,04,c1)},
	{hx::fsObject /*Dynamic*/ ,(int)offsetof(TShaderContext_obj,stencil_reference_value),HX_("stencil_reference_value",3a,f1,d8,44)},
	{hx::fsObject /*Dynamic*/ ,(int)offsetof(TShaderContext_obj,stencil_read_mask),HX_("stencil_read_mask",72,46,a7,66)},
	{hx::fsObject /*Dynamic*/ ,(int)offsetof(TShaderContext_obj,stencil_write_mask),HX_("stencil_write_mask",2f,00,c1,a4)},
	{hx::fsObject /*Dynamic*/ ,(int)offsetof(TShaderContext_obj,color_write_red),HX_("color_write_red",95,8d,56,11)},
	{hx::fsObject /*Dynamic*/ ,(int)offsetof(TShaderContext_obj,color_write_green),HX_("color_write_green",07,5c,75,b1)},
	{hx::fsObject /*Dynamic*/ ,(int)offsetof(TShaderContext_obj,color_write_blue),HX_("color_write_blue",d6,49,d7,0f)},
	{hx::fsObject /*Dynamic*/ ,(int)offsetof(TShaderContext_obj,color_write_alpha),HX_("color_write_alpha",a2,f4,1e,39)},
	{hx::fsObject /*Dynamic*/ ,(int)offsetof(TShaderContext_obj,conservative_raster),HX_("conservative_raster",0f,38,63,6e)},
	{hx::fsObject /*Dynamic*/ ,(int)offsetof(TShaderContext_obj,shader_from_source),HX_("shader_from_source",f6,0e,37,d1)},
	{ hx::fsUnknown, 0, null()}
};
static hx::StaticInfo *TShaderContext_obj_sStaticStorageInfo = 0;
#endif

static ::String TShaderContext_obj_sMemberFields[] = {
	HX_("name",4b,72,ff,48),
	HX_("depth_write",63,c9,b5,19),
	HX_("compare_mode",7d,60,f4,04),
	HX_("cull_mode",50,c4,74,6c),
	HX_("vertex_structure",58,50,9b,df),
	HX_("vertex_shader",e0,e9,85,30),
	HX_("fragment_shader",f4,0a,a9,c5),
	HX_("geometry_shader",52,68,06,7a),
	HX_("tesscontrol_shader",18,8f,62,58),
	HX_("tesseval_shader",f7,37,49,43),
	HX_("constants",8f,76,6b,44),
	HX_("texture_units",cb,0f,52,01),
	HX_("blend_source",49,f6,96,02),
	HX_("blend_destination",60,d6,9d,4e),
	HX_("blend_operation",79,d7,69,41),
	HX_("alpha_blend_source",0a,1f,b7,8a),
	HX_("alpha_blend_destination",ff,51,cd,c3),
	HX_("alpha_blend_operation",58,dd,64,7d),
	HX_("stencil_mode",c6,ff,af,c5),
	HX_("stencil_pass",34,11,a1,c7),
	HX_("stencil_fail",41,e6,04,c1),
	HX_("stencil_reference_value",3a,f1,d8,44),
	HX_("stencil_read_mask",72,46,a7,66),
	HX_("stencil_write_mask",2f,00,c1,a4),
	HX_("color_write_red",95,8d,56,11),
	HX_("color_write_green",07,5c,75,b1),
	HX_("color_write_blue",d6,49,d7,0f),
	HX_("color_write_alpha",a2,f4,1e,39),
	HX_("conservative_raster",0f,38,63,6e),
	HX_("shader_from_source",f6,0e,37,d1),
	::String(null()) };

hx::Class TShaderContext_obj::__mClass;

void TShaderContext_obj::__register()
{
	TShaderContext_obj _hx_dummy;
	TShaderContext_obj::_hx_vtable = *(void **)&_hx_dummy;
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_("iron.data.TShaderContext",f4,17,16,5b);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = hx::Class_obj::dupFunctions(TShaderContext_obj_sMemberFields);
	__mClass->mCanCast = hx::TCanCast< TShaderContext_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = TShaderContext_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = TShaderContext_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace iron
} // end namespace data
